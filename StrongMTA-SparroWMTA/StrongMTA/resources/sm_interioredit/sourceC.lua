pcall(loadstring(base64Decode(exports.sm_core:getInterfaceElements())));addEventHandler("onCoreStarted",root,function(functions) for k,v in ipairs(functions) do _G[v]=nil;end;collectgarbage();pcall(loadstring(base64Decode(exports.sm_core:getInterfaceElements())));end)

local debugMode = false

local editorModels = {
	floor = 17132,
	half = 17134,
	straight = 17141,
	two = 17145,
	three = 17133,
	four = 17143,
	base = 17140,
	door = 17142,
	door2 = 17130,
	window = 17144
}

function loadColAndDff(model, fileName, txd)
	local col = engineLoadCOL(fileName .. ".col")
	local dff = engineLoadDFF(fileName .. ".dff")

	engineImportTXD(txd, model)
	engineReplaceCOL(col, model)
	engineReplaceModel(dff, model, true)
end

local txd = engineLoadTXD("files/models/textures.txd")
loadColAndDff(editorModels.floor, "files/models/floor", txd)
loadColAndDff(editorModels.half, "files/models/half", txd)
loadColAndDff(editorModels.straight, "files/models/straight", txd)
loadColAndDff(editorModels.two, "files/models/two", txd)
loadColAndDff(editorModels.three, "files/models/three", txd)
loadColAndDff(editorModels.four, "files/models/four", txd)
loadColAndDff(editorModels.base, "files/models/basewall", txd)
loadColAndDff(editorModels.door, "files/models/door", txd)
loadColAndDff(editorModels.door2, "files/models/door2", txd)
loadColAndDff(editorModels.window, "files/models/window", txd)

local txd = engineLoadTXD("files/models/furnitures/tv.txd")
loadColAndDff(2648, "files/models/furnitures/tv1", txd)
loadColAndDff(14772, "files/models/furnitures/tv2", txd)

local txd = engineLoadTXD("files/models/furnitures/urma4k.txd")
loadColAndDff(1786, "files/models/furnitures/urma4k", txd)

function reMap(value, low1, high1, low2, high2)
	return low2 + (value - low1) * (high2 - low2) / (high1 - low1)
end

local screenX, screenY = guiGetScreenSize()
local responsiveMultipler = reMap(screenX, 1024, 1920, 0.75, 1)

function resp(num)
	return num * responsiveMultipler
end

function respc(num)
	return math.ceil(num * responsiveMultipler)
end

local editorX, editorY, editorZ = 37.9, 2034.5, 50
local editableX, editableY = 10, 10
local editingInterior = false
local editorZone = {}

local Roboto = false
local RobotoL = false
local RobotoLHeight = false

local menuHeight = respc(140)
local menuItemMargin = respc(5)
local menuItemNum = 15
local menuItemWidth = math.ceil(screenX - menuItemMargin) / menuItemNum
local menuItemHeight = menuHeight

local navHeight = respc(40)
local navIconSize = respc(32)
local navMargin = respc(5)
local navDivWidth = false

local cursorAbsPos = false
local cursorRelPos = false
local cursorX = -1
local cursorY = -1
local oldActiveButton = false
local activeButton = false

local activeMenu = "walls"
local activeSubMenu = "drawing"
local activeMode = false

local gridInnerZ = 0.15
local gridOuterZ = -0.15
local gridLineSize = 1.5
local gridDefaultColor = tocolor(255, 255, 255)
local gridColor = tocolor(61, 122, 188)
local gridLine = dxCreateTexture("files/textures/selection.png")
local gridVisible = true

local cameraPivot = false
local cameraYaw = 225
local cameraPitch = 35
local cameraZoom = 40
local cameraReversed = false

local oneTileSize = false
local oneTileWidth = false

local floors = {}
local floorPositions = {}
local floorObjects = {}

local baseWalls = {}
local baseWallPositions = {}
local baseWallObjects = {}

local walls = {}
local wallPositions = {}
local wallObjects = {}

local ceils = {}
local ceilPositions = {}
local ceilObjects = {}

local placedBaseDoor = false
local baseDoorColShape = false
local currentBaseDoor = false

local doorObjects = {}
local doorPositions = {}
local doorRotations = {}
local doorColShape = {}
local doorColPosition = {}
local placedDoor = false
local doorStates = {}

local windowPositions = {}
local windowObjects = {}

local lastActiveTileX = false
local lastActiveTileY = false
local activeTileX = false
local activeTileY = false
local activeTileLine = false
local activeTiles = {}

local selectedTileX = false
local selectedTileY = false
local selectedTileLine = false
local selectedTileAxis = false

local texturesCount = {
	wall = {
		paint = 20,
		tile = 20,
		wallpaper = 68
	},
	floor = {
		carpet = 21,
		tile = 49,
		wood = 32
	},
	ceil = {
		normal = 25
	},
	door = {
		["1"] = 5,
		["2"] = 2,
		["3"] = 5,
		["4"] = 7
	},
	window = {
		normal = 10
	}
}

local availableTextures = {}
local menuOffset = {}

local textureShaders = {}
local texturePaths = {}
local textureUses = {}

local smallPaths = {}
local bigPaths = {}
local pathId = 1

for mainType in pairs(texturesCount) do
	availableTextures[mainType] = {}
	menuOffset[mainType] = {}

	for subType, textureTypes in pairs(texturesCount[mainType]) do
		menuOffset[mainType][subType] = 0
		availableTextures[mainType][subType] = {}

		for i = 1, textureTypes do
			availableTextures[mainType][subType][i] = dxCreateTexture("files/textures/" .. mainType .. "/" .. subType .. "/" .. i .. ".png", "dxt1")

			smallPaths[mainType .. "," .. subType .. "," .. i] = pathId
			bigPaths[pathId] = mainType .. "," .. subType .. "," .. i

			pathId = pathId + 1
		end
	end
end

function smallTextureName(textureName)
	return utf8.sub(textureName, 6)
end

function bigTextureName(edge)
	return "tile_" .. edge
end

function smallPathName(pathName)
	return smallPaths[pathName]
end

function bigPathName(pathId)
	return bigPaths[tonumber(pathId)]
end

local boundingBox = {
	[2069] = {0.22464027404784, 0.20464027404784, 2.0946402740478, -0.16535972595216, -0.18535972595216, -0.045359725952156, 0.029640274047844, 0.0096402740478443, 1.0246402740478},
	[2023] = {0.37782579421997, 0.37782579421997, 2.07782579422, -0.36217420578003, -0.36217420578003, 0.0078257942199685, 0.0078257942199685, 0.0078257942199685, 1.04282579422},
	[1416] = {0.7160261297226, 0.3760261297226, 0.5760261297226, -0.6939738702774, -0.3539738702774, -0.5639738702774, 0.011026129722597, 0.011026129722597, 0.0060261297225968},
	[1417] = {0.53942593574524, 0.30942593574524, 1.0594259357452, -0.50057406425476, -0.28057406425476, -0.26057406425476, 0.019425935745241, 0.014425935745241, 0.39942593574524},
	[1740] = {0.27900499343872, 1.4090049934387, 1.0690049934387, -0.30099500656128, 0.81900499343872, 0.0090049934387218, -0.010995006561278, 1.1140049934387, 0.53900499343872},
	[1741] = {1.4819871139526, 1.4919871139526, 1.1419871139526, -0.45801288604737, 0.72198711395263, 0.01198711395263, 0.51198711395263, 1.1069871139526, 0.57698711395263},
	[1816] = {0.90084974765778, 0.83084974765778, 0.50084974765778, 0.11084974765778, 0.19084974765778, 0.010849747657777, 0.50584974765778, 0.51084974765778, 0.25584974765778},
	[2025] = {1.4756062602997, 0.47560626029966, 2.5156062602996, -0.48439373970034, -0.46439373970034, 0.0056062602996559, 0.49560626029966, 0.0056062602996559, 1.2606062602997},
	[2087] = {1.5473048591614, 0.18730485916137, 1.1573048591614, -0.48269514083863, -0.48269514083863, 0.0073048591613692, 0.53230485916137, -0.14769514083863, 0.58230485916137},
	[2088] = {1.2629102134704, 1.4629102134704, 1.9229102134704, -0.25708978652955, 0.68291021347045, 0.012910213470448, 0.50291021347045, 1.0729102134704, 0.96791021347045},
	[2089] = {1.3233276557922, 0.24332765579223, 1.1833276557922, -0.48667234420777, -0.48667234420777, 0.013327655792232, 0.41832765579223, -0.12167234420777, 0.59832765579223},
	[2094] = {1.4951193809509, 1.4951193809509, 0.99511938095092, -0.47488061904908, 0.86511938095092, 0.005119380950923, 0.51011938095092, 1.1801193809509, 0.50011938095092},
	[2095] = {0.37957888603211, 1.4295788860321, 0.93957888603211, -0.36042111396789, 0.72957888603211, 0.0095788860321056, 0.0095788860321056, 1.0795788860321, 0.47457888603211},
	[2200] = {1.7444894218445, 0.15448942184446, 1.8944894218445, -0.47551057815554, -0.47551057815554, 0.004489421844463, 0.63448942184446, -0.16051057815554, 0.94948942184446},
	[2307] = {1.4919722938537, 1.5119722938537, 2.2919722938537, -0.47802770614626, 0.88197229385374, 0.0019722938537382, 0.50697229385374, 1.1969722938537, 1.1469722938537},
	[2323] = {1.473672208786, 1.493672208786, 1.003672208786, -0.47632779121399, 0.73367220878601, 0.013672208786005, 0.49867220878601, 1.113672208786, 0.50867220878601},
	[2328] = {0.48432559967041, 1.4643255996704, 0.79432559967041, -0.45567440032959, 0.72432559967041, 0.0043255996704113, 0.014325599670411, 1.0943255996704, 0.39932559967041},
	[2329] = {1.4964088344574, 1.5064088344574, 2.2964088344574, -0.47359116554263, 0.67640883445738, 0.0064088344573748, 0.51140883445738, 1.0914088344574, 1.1514088344574},
	[2330] = {1.4784892559051, 1.4984892559051, 2.2984892559051, -0.48151074409487, 0.73848925590513, 0.018489255905129, 0.49848925590513, 1.1184892559051, 1.1584892559051},
	[2576] = {3.072479019165, 0.47247901916499, 2.152479019165, 0.18247901916499, -0.29752098083501, 0.012479019164994, 1.627479019165, 0.087479019164994, 1.082479019165},
	[2708] = {1.9049079036712, 0.30490790367123, 2.4949079036712, -0.47509209632877, -0.49509209632877, 0.0049079036712333, 0.71490790367123, -0.095092096328767, 1.2499079036712},
	[1700] = {1.374770450592, 3.454770450592, 0.73477045059199, -0.34522954940801, 1.144770450592, 0.014770450591991, 0.51477045059199, 2.299770450592, 0.37477045059199},
	[1701] = {1.4834101772308, 3.4934101772308, 0.7534101772308, -0.4765898227692, 1.0034101772308, 0.073410177230798, 0.5034101772308, 2.2484101772308, 0.4134101772308},
	[1745] = {1.4187220859527, 3.4287220859527, 0.68872208595272, -0.40127791404728, 0.81872208595272, 0.0087220859527229, 0.50872208595272, 2.1237220859527, 0.34872208595272},
	[1793] = {1.4380783271789, 3.4780783271789, 0.63807832717893, -0.50192167282108, 0.74807832717893, 0.0080783271789252, 0.46807832717893, 2.1130783271789, 0.32307832717893},
	[1794] = {1.4000304031372, 3.4900304031371, 0.67003040313716, -0.46996959686284, 1.1500304031372, -0.019969596862842, 0.46503040313716, 2.3200304031371, 0.32503040313716},
	[1795] = {1.4404919147491, 3.3004919147491, 0.47049191474912, -0.46950808525088, 0.85049191474912, 0.010491914749119, 0.48549191474912, 2.0754919147491, 0.24049191474912},
	[1796] = {0.71714859008787, 3.0771485900878, 0.64714859008787, -0.48285140991213, 1.1371485900879, 0.017148590087869, 0.11714859008787, 2.1071485900879, 0.33214859008787},
	[1797] = {1.3804919528961, 3.3404919528961, 0.49049195289609, -0.39950804710391, 1.2404919528961, 0.17049195289609, 0.49049195289609, 2.2904919528961, 0.33049195289609},
	[1798] = {1.4991759777069, 3.4891759777068, 0.49917597770687, -0.49082402229313, 0.73917597770688, 0.0091759777068746, 0.50417597770687, 2.1141759777069, 0.25417597770687},
	[1799] = {1.4220509624481, 3.3320509624481, 0.62205096244809, -0.45794903755191, 0.88205096244809, 0.16205096244809, 0.48205096244809, 2.1070509624481, 0.39205096244809},
	[1800] = {0.75243659973142, 3.2024365997314, 0.76243659973142, -0.45756340026858, 1.1024365997314, 0.0024365997314214, 0.14743659973142, 2.1524365997314, 0.38243659973142},
	[1801] = {1.3255684661865, 3.4455684661865, 0.63556846618649, -0.33443153381351, 1.0555684661865, 0.0055684661864942, 0.49556846618649, 2.2505684661865, 0.32056846618649},
	[1802] = {1.3674041652679, 3.4674041652679, 0.70740416526791, -0.30259583473209, 0.96740416526791, 0.027404165267913, 0.53240416526791, 2.2174041652679, 0.36740416526791},
	[1803] = {1.4391089725494, 3.4891089725494, 1.9591089725494, -0.4308910274506, 0.9891089725494, 0.019108972549404, 0.5041089725494, 2.2391089725494, 0.9891089725494},
	[1812] = {0.45853260993956, 2.4785326099396, 0.46853260993956, -0.48146739006044, 0.14853260993956, 0.038532609939559, -0.011467390060441, 1.3135326099396, 0.25353260993956},
	[2090] = {1.4383177566528, 3.4883177566527, 1.3283177566528, -0.38168224334722, 0.98831775665278, 0.01831775665278, 0.52831775665278, 2.2383177566528, 0.67331775665278},
	[2298] = {3.1244121170043, 3.9644121170043, 0.53441211700431, -0.46558788299569, 1.1644121170043, 0.014412117004312, 1.3294121170043, 2.5644121170043, 0.27441211700431},
	[2299] = {1.3915691947937, 3.4915691947936, 0.69156919479367, -0.39843080520633, 0.98156919479367, 0.011569194793667, 0.49656919479367, 2.2365691947937, 0.35156919479367},
	[2300] = {3.0927723121642, 4.4827723121642, 2.2727723121642, -0.42722768783579, 1.2627723121642, 0.0027723121642077, 1.3327723121642, 2.8727723121642, 1.1377723121642},
	[2301] = {1.4546286392211, 3.5046286392211, 1.5446286392211, -0.47537136077887, 0.58462863922113, 0.01462863922113, 0.48962863922113, 2.0446286392211, 0.77962863922113},
	[2302] = {1.4046100139618, 3.3546100139617, 0.70461001396176, -0.41538998603824, 0.80461001396176, 0.26461001396176, 0.49461001396176, 2.0796100139617, 0.48461001396176},
	[2331] = {0.33062665939331, 0.28062665939331, 0.42062665939331, -0.31937334060669, -0.26937334060669, -0.23937334060669, 0.0056266593933114, 0.0056266593933114, 0.090626659393311},
	[2333] = {1.4548001194, 1.4848001194, 0.96480011940002, -0.42519988059998, 0.62480011940002, 0.01480011940002, 0.51480011940002, 1.0548001194, 0.48980011940002},
	[2563] = {3.4357198524474, 2.4757198524474, 1.3057198524474, -0.41428014755258, 0.055719852447417, 0.015719852447417, 1.5107198524474, 1.2657198524474, 0.66071985244742},
	[2564] = {5.3104440689085, 2.4804440689086, 1.3104440689086, -0.26955593109144, 0.020444068908562, 0.010444068908562, 2.5204440689085, 1.2504440689086, 0.66044406890856},
	[2565] = {5.3261133766172, 2.4961133766173, 0.046113376617314, -0.33388662338269, 0.056113376617314, -0.57388662338269, 2.4961133766173, 1.2761133766173, -0.26388662338269},
	[2566] = {3.3480203628539, 2.4880203628539, 0.11802036285395, -0.32197963714605, 0.048020362853948, -0.57197963714605, 1.5130203628539, 1.2680203628539, -0.22697963714605},
	[2575] = {3.1471459960937, 2.4871459960937, 0.27714599609368, -0.14285400390632, 0.09714599609368, -0.37285400390632, 1.5021459960937, 1.2921459960937, -0.04785400390632},
	[14446] = {1.8436717033386, 1.6836717033386, 0.12367170333855, -1.8263282966615, -1.7363282966615, -0.58632829666145, 0.0086717033385489, -0.026328296661451, -0.23132829666145},
	[2724] = {0.32140323638916, 0.37140323638916, 0.55140323638916, -0.30859676361084, -0.35859676361084, -0.53859676361084, 0.0064032363891615, 0.0064032363891615, 0.0064032363891615},
	[2725] = {0.35262693405151, 0.33262693405151, 0.43262693405151, -0.33737306594849, -0.30737306594849, -0.42737306594849, 0.0076269340515147, 0.012626934051515, 0.0026269340515147},
	[3383] = {1.9910430335998, 0.8410430335998, 2.1210430335998, -1.9789569664002, -0.8289569664002, 0.0010430335997978, 0.0060430335997977, 0.0060430335997978, 1.0610430335998},
	[16151] = {1.1245203781126, 4.2745203781126, 1.5245203781126, -2.1554796218874, -3.6854796218873, -0.38547962188735, -0.51547962188735, 0.29452037811264, 0.56952037811265},
	[2224] = {0.5709436416626, 1.2809436416626, 1.2809436416626, -0.2190563583374, 0.4909436416626, 0.4909436416626, 0.1759436416626, 0.8859436416626, 0.8859436416626},
	[2452] = {1.0832596969604, 0.37325969696043, 2.4432596969604, -0.48674030303957, -0.48674030303957, 0.013259696960429, 0.29825969696043, -0.056740303039571, 1.2282596969604},
	[2627] = {0.40206603050229, 1.0320660305023, 0.17206603050229, -0.37793396949771, -1.0579339694977, 0.0020660305022916, 0.012066030502292, -0.012933969497709, 0.087066030502292},
	[2630] = {0.16793656349182, 0.75793656349182, 1.2679365634918, -0.15206343650818, -0.73206343650818, 0.0079365634918212, 0.0079365634918212, 0.012936563491821, 0.63793656349182},
	[2628] = {0.50772869110105, 0.71772869110105, 2.387728691101, -0.49227130889895, -0.90227130889895, 0.0077286911010469, 0.0077286911010468, -0.092271308898953, 1.197728691101},
	[2629] = {0.57528366088866, 0.74528366088866, 1.1152836608887, -0.54471633911134, -0.69471633911134, 0.0052836608886562, 0.015283660888656, 0.025283660888656, 0.56028366088866},
	[2916] = {0.23005158782005, 0.11005158782005, 0.12005158782005, -0.19994841217995, -0.10994841217995, -0.099948412179947, 0.015051587820053, 5.1587820053406e-05, 0.010051587820053},
	[2915] = {0.21313235521317, 0.11313235521317, 0.10313235521317, -0.64686764478683, -0.10686764478683, -0.10686764478683, -0.21686764478683, 0.003132355213166, -0.001867644786834},
	[1585] = {0.66281067848205, -0.017189321517947, 1.8528106784821, -0.51718932151795, -0.077189321517947, 0.012810678482053, 0.072810678482053, -0.047189321517947, 0.93281067848205},
	[1584] = {0.46804646492004, -0.011953535079956, 1.85804646492, -0.61195353507996, -0.081953535079956, 0.0080464649200441, -0.071953535079956, -0.046953535079956, 0.93304646492004},
	[1583] = {0.69104640007019, -0.018953599929813, 1.8510464000702, -0.55895359992981, -0.058953599929813, 0.011046400070187, 0.066046400070187, -0.038953599929813, 0.93104640007019},
	[2484] = {0.77742227554321, 0.17742227554321, 0.83742227554321, -0.76257772445679, -0.16257772445679, -0.83257772445679, 0.0074222755432079, 0.0074222755432079, 0.0024222755432079},
	[2491] = {0.00049067497253583, 0.010490674972536, 1.8804906749725, -0.48950932502746, -0.47950932502746, 0.010490674972536, -0.24450932502746, -0.23450932502746, 0.94549067497254},
	[2489] = {0.30289549589157, 0.12289549589157, 0.13289549589157, -0.29710450410843, -0.097104504108428, -0.12710450410843, 0.0028954958915715, 0.012895495891572, 0.0028954958915715},
	[2490] = {0.30289549589157, 0.12289549589157, 0.13289549589157, -0.29710450410843, -0.097104504108428, -0.12710450410843, 0.0028954958915715, 0.012895495891572, 0.0028954958915715},
	[2500] = {0.047835941314698, 0.087835941314698, 0.7278359413147, -0.4721640586853, -0.4721640586853, 0.0078359413146981, -0.2121640586853, -0.1921640586853, 0.3678359413147},
	[2581] = {1.0958309650421, 0.23583096504209, 1.1558309650421, -1.0641690349579, -0.19416903495791, -1.1441690349579, 0.01583096504209, 0.02083096504209, 0.0058309650420902},
	[2584] = {0.4373872089386, 0.4373872089386, 0.8273872089386, -0.4026127910614, -0.4026127910614, -0.8126127910614, 0.017387208938599, 0.017387208938599, 0.0073872089385994},
	[1775] = {0.60941699028014, 0.48941699028014, 1.0994169902801, -0.58058300971986, -0.43058300971986, -1.0905830097199, 0.014416990280139, 0.029416990280139, 0.0044169902801386},
	[1776] = {0.60520695686339, 0.40520695686339, 1.0952069568634, -0.58479304313661, -0.38479304313661, -1.0947930431366, 0.010206956863392, 0.010206956863392, 0.00020695686339145},
	[2743] = {0.45316757202147, 0.44316757202147, -0.64683242797853, -0.44683242797853, -0.44683242797853, -1.3468324279785, 0.0031675720214662, -0.0018324279785338, -0.99683242797853},
	[1369] = {0.37861600875855, 0.43861600875855, 0.24861600875855, -0.36138399124145, -0.41138399124145, -0.59138399124145, 0.0086160087585464, 0.013616008758546, -0.17138399124145},
	[1985] = {0.30378440856933, 0.30378440856933, -0.48621559143067, -0.29621559143067, -0.29621559143067, -2.4162155914307, 0.0037844085693274, 0.0037844085693274, -1.4512155914307},
	[3461] = {0.30308491706846, 0.30308491706846, 1.5730849170685, -0.28691508293154, -0.28691508293154, -1.5669150829315, 0.0080849170684562, 0.0080849170684562, 0.0030849170684561},
	[3534] = {0.59924886703491, 0.59924886703491, 0.18924886703491, -0.59075113296509, -0.59075113296509, -1.3007511329651, 0.0042488670349132, 0.0042488670349132, -0.55575113296509},
	[3385] = {0.29953380823135, 0.29953380823135, 0.049533808231354, -0.29046619176865, -0.29046619176865, 0.0095338082313544, 0.0045338082313544, 0.0045338082313544, 0.029533808231354},
	[2976] = {0.22108490467072, 0.22108490467072, 0.77108490467072, -0.20891509532928, -0.20891509532928, 0.011084904670716, 0.0060849046707161, 0.0060849046707161, 0.39108490467072},
	[1829] = {0.42589489936828, 0.74589489936828, 0.47589489936828, -0.42410510063172, -0.72410510063172, -0.45410510063172, 0.00089489936828266, 0.010894899368283, 0.010894899368283},
	[2778] = {0.41319259643554, 0.50319259643554, 2.0831925964355, -0.36680740356446, -0.45680740356446, 0.01319259643554, 0.02319259643554, 0.02319259643554, 1.0481925964355},
	[2779] = {0.41319259643554, 0.50319259643554, 2.0831925964355, -0.36680740356446, -0.45680740356446, 0.01319259643554, 0.02319259643554, 0.02319259643554, 1.0481925964355},
	[2872] = {0.40872463226318, 0.49872463226318, 2.0887246322632, -0.36127536773682, -0.47127536773682, 0.0087246322631761, 0.023724632263176, 0.013724632263176, 1.0487246322632},
	[630] = {0.083888816833488, 0.20388881683349, 0.33388881683349, -0.28611118316651, -0.16611118316651, -0.92611118316651, -0.10111118316651, 0.018888816833488, -0.29611118316651},
	[631] = {0.16946226119995, 0.20946226119995, 0.57946226119995, -0.21053773880005, -0.17053773880005, -0.85053773880005, -0.02053773880005, 0.01946226119995, -0.13553773880005},
	[632] = {-0.49768731117252, 0.39231268882748, 2.3023126888275, -1.2876873111725, -0.39768731117252, -0.43768731117252, -0.89268731117252, -0.0026873111725214, 0.93231268882748},
	[633] = {0.29269082069396, 0.31269082069396, 0.27269082069396, -0.32730917930604, -0.30730917930604, -0.98730917930604, -0.01730917930604, 0.0026908206939603, -0.35730917930604},
	[638] = {0.371261806488, 1.351261806488, -0.298738193512, -0.338738193512, -1.328738193512, -0.688738193512, 0.016261806488, 0.011261806487999, -0.493738193512},
	[646] = {0.32043624877926, 0.10043624877926, -0.94956375122074, -0.13956375122074, -0.35956375122074, -1.4095637512207, 0.090436248779263, -0.12956375122074, -1.1795637512207},
	[948] = {0.26857079505921, 0.27857079505921, 0.67857079505921, -0.25142920494079, -0.24142920494079, 0.0085707950592056, 0.0085707950592056, 0.018570795059206, 0.34357079505921},
	[949] = {0.25055651187897, 0.26055651187897, -0.21944348812103, -0.21944348812103, -0.21944348812103, -0.62944348812103, 0.015556511878969, 0.020556511878969, -0.42444348812103},
	[950] = {0.48227576255799, 0.32227576255799, -0.067724237442015, -0.41772423744202, -0.23772423744202, -0.53772423744202, 0.032275762557985, 0.042275762557985, -0.30272423744202},
	[1361] = {0.50353079795837, 0.50353079795837, 0.74353079795838, -0.48646920204163, -0.48646920204163, -0.73646920204163, 0.0085307979583746, 0.0085307979583746, 0.0035307979583746},
	[2001] = {0.1321360206604, 0.2921360206604, 1.7721360206604, -0.2378639793396, -0.1678639793396, 0.0021360206604016, -0.052863979339598, 0.062136020660402, 0.8871360206604},
	[2010] = {0.45066651344298, 0.47066651344298, 0.90066651344298, -0.45933348655702, -0.45933348655702, -0.89933348655702, -0.004333486557024, 0.0056665134429761, 0.00066651344297602},
	[2011] = {0.32557581901548, 0.48557581901548, 0.99557581901548, -0.26442418098452, -0.47442418098452, -0.99442418098452, 0.03057581901548, 0.0055758190154798, 0.00057581901547982},
	[2194] = {0.17008832931519, 0.18008832931519, 0.020088329315186, -0.16991167068481, -0.15991167068481, -0.32991167068481, 8.8329315186181e-05, 0.010088329315186, -0.15491167068481},
	[2195] = {0.3653041601181, 0.3753041601181, -0.2446958398819, -0.3446958398819, -0.3346958398819, -0.6146958398819, 0.010304160118105, 0.020304160118105, -0.4296958398819},
	[2240] = {0.3668544960022, 0.3468544960022, 0.086854496002199, -0.3531455039978, -0.3331455039978, -0.5931455039978, 0.0068544960021986, 0.0068544960021986, -0.2531455039978},
	[2241] = {0.35875689506531, 0.30875689506531, 0.078756895065309, -0.35124310493469, -0.30124310493469, -0.47124310493469, 0.0037568950653088, 0.0037568950653088, -0.19624310493469},
	[2244] = {0.1885004234314, 0.1685004234314, 0.1285004234314, -0.1414995765686, -0.1614995765686, -0.2714995765686, 0.023500423431397, 0.0035004234313971, -0.071499576568603},
	[2251] = {0.33450789451599, 0.19450789451599, 0.85450789451599, -0.31549210548401, -0.18549210548401, -0.83549210548401, 0.0095078945159927, 0.0045078945159927, 0.0095078945159927},
	[2252] = {0.36155427932739, 0.33155427932739, 0.021554279327393, -0.30844572067261, -0.33844572067261, -0.31844572067261, 0.026554279327393, -0.0034457206726067, -0.14844572067261},
	[2253] = {0.18995675563812, 0.16995675563812, 0.10995675563812, -0.14004324436188, -0.17004324436188, -0.28004324436188, 0.024956755638123, -4.3244361876887e-05, -0.085043244361877},
	[2811] = {0.20214985847473, 0.20214985847473, 0.40214985847473, -0.18785014152527, -0.18785014152527, 0.012149858474733, 0.0071498584747329, 0.0071498584747329, 0.20714985847473},
	[14834] = {0.3801416492462, 0.3601416492462, 2.3001416492462, -0.3498583507538, -0.3598583507538, -0.2698583507538, 0.015141649246196, 0.00014164924619572, 1.0151416492462},
	[2571] = {1.9727131938934, 1.2927131938934, 0.4827131938934, 1.0627131938934, 0.4027131938934, 0.0027131938933974, 1.5177131938934, 0.8477131938934, 0.2427131938934},
	[2357] = {2.1249024009704, 0.65490240097041, 0.40490240097041, -2.1250975990296, -0.65509759902959, -0.39509759902959, -9.7599029593498e-05, -9.7599029593332e-05, 0.0049024009704067},
	[2290] = {2.4896639060974, 0.49966390609738, 0.92966390609738, -0.49033609390263, -0.48033609390263, -0.00033609390262526, 0.99966390609737, 0.0096639060973747, 0.46466390609738},
	[2239] = {0.10354538917541, 0.083545389175409, 2.3035453891754, -0.076454610824591, -0.076454610824591, 0.0035453891754092, 0.013545389175409, 0.0035453891754092, 1.1535453891754},
	[2119] = {1.4962490558624, 0.49624905586242, 0.78624905586242, -0.48375094413758, -0.48375094413758, 0.016249055862421, 0.50624905586242, 0.0062490558624209, 0.40124905586242},
	[2118] = {1.504731760025, 0.49473176002502, 0.78473176002502, -0.47526823997498, -0.47526823997498, 0.014731760025019, 0.51473176002502, 0.0097317600250186, 0.39973176002502},
	[2117] = {1.4973248100281, 0.49732481002807, 0.79732481002807, -0.48267518997193, -0.48267518997193, 0.0073248100280701, 0.50732481002807, 0.0073248100280701, 0.40232481002807},
	[2116] = {1.5017372131348, 0.49173721313476, 0.79173721313476, -0.46826278686524, -0.47826278686524, 0.01173721313476, 0.51673721313476, 0.00673721313476, 0.40173721313476},
	[2115] = {1.4909554290771, 0.49095542907714, 0.80095542907714, -0.46904457092286, -0.47904457092286, 0.00095542907714305, 0.51095542907714, 0.0059554290771431, 0.40095542907714},
	[2109] = {0.85525788307189, 0.84525788307189, 0.41525788307189, -0.84474211692811, -0.83474211692811, -0.38474211692811, 0.0052578830718897, 0.0052578830718897, 0.01525788307189},
	[2111] = {0.85785785675048, 0.83785785675048, 0.46785785675048, -0.84214214324952, -0.83214214324952, -0.38214214324952, 0.0078578567504782, 0.0028578567504782, 0.042857856750478},
	[2112] = {0.70216523170471, 0.69216523170471, 0.47216523170471, -0.69783476829529, -0.68783476829529, -0.38783476829529, 0.0021652317047103, 0.0021652317047103, 0.04216523170471},
	[2108] = {0.21092791557311, 0.22092791557311, 2.0409279155731, -0.17907208442689, -0.16907208442689, 0.00092791557311154, 0.015927915573112, 0.025927915573112, 1.0209279155731},
	[1768] = {2.4034939861297, 0.49349398612973, 1.0034939861297, -0.37650601387027, -0.46650601387027, 0.0034939861297315, 1.0134939861297, 0.013493986129731, 0.50349398612973},
	[1766] = {2.3853976154327, 0.49539761543271, 1.0153976154327, -0.33460238456729, -0.46460238456729, 0.015397615432708, 1.0253976154327, 0.015397615432708, 0.51539761543271},
	[1764] = {2.1534077167511, 0.51340771675108, 0.99340771675108, -0.12659228324892, -0.47659228324892, 0.013407716751079, 1.0134077167511, 0.018407716751079, 0.50340771675108},
	[1763] = {1.7142655658722, 0.50426556587217, 1.0442655658722, -0.46573443412783, -0.29573443412783, 0.0042655658721725, 0.62426556587217, 0.10426556587217, 0.52426556587217},
	[1761] = {2.3950518226623, 0.48505182266232, 1.0250518226623, -0.39494817733768, -0.46494817733768, 0.0050518226623187, 1.0000518226623, 0.010051822662319, 0.51505182266232},
	[1760] = {2.4365927505493, 0.41659275054928, 1.0265927505493, -0.41340724945072, -0.47340724945072, 0.006592750549281, 1.0115927505493, -0.028407249450719, 0.51659275054928},
	[1757] = {2.3855776309967, 0.49557763099667, 1.0155776309967, -0.36442236900333, -0.47442236900333, 0.0055776309966725, 1.0105776309967, 0.010577630996672, 0.51057763099667},
	[1756] = {2.2251965808868, 0.58519658088681, 1.1051965808868, -0.4748034191132, -0.4848034191132, 0.045196580886805, 0.8751965808868, 0.050196580886805, 0.57519658088681},
	[1753] = {2.4661975288391, 0.48619752883907, 0.93619752883907, -0.42380247116093, -0.48380247116093, 0.026197528839074, 1.0211975288391, 0.0011975288390742, 0.48119752883907},
	[1713] = {2.0817562866211, 0.50175628662106, 0.98175628662106, -0.46824371337894, -0.47824371337894, 0.18175628662106, 0.80675628662106, 0.011756286621061, 0.58175628662106},
	[1712] = {1.9338789272308, 0.50387892723081, 1.0138789272308, -0.46612107276919, -0.48612107276919, 0.0038789272308134, 0.73387892723081, 0.0088789272308133, 0.50887892723081},
	[1710] = {4.1042019653319, 0.50420196533196, 0.99420196533196, -0.38579803466804, -0.42579803466804, 0.0042019653319621, 1.8592019653319, 0.039201965331962, 0.49920196533196},
	[1709] = {6.0119393920897, 1.5319393920897, 1.0019393920897, -0.47806060791025, -0.48806060791025, 0.10193939208975, 2.7669393920897, 0.52193939208975, 0.55193939208975},
	[1707] = {2.064418182373, 0.60441818237303, 0.95441818237303, -0.47558181762697, -0.48558181762697, 0.054418182373032, 0.79441818237303, 0.059418182373032, 0.50441818237303},
	[1706] = {1.5877992725372, 0.4777992725372, 0.9477992725372, -0.5722007274628, -0.4622007274628, 0.0077992725372039, 0.5077992725372, 0.0077992725372039, 0.4777992725372},
	[1703] = {2.2822599029541, 0.50225990295407, 0.99225990295407, -0.24774009704593, -0.45774009704593, 0.0022599029540676, 1.0172599029541, 0.022259902954068, 0.49725990295407},
	[1702] = {2.0501325130462, 0.51013251304624, 0.87013251304624, -0.049867486953759, -0.45986748695376, 0.12013251304624, 1.0001325130462, 0.025132513046241, 0.49513251304624},
	[1742] = {0.94239231109618, -0.12760768890382, 2.0323923110962, -0.47760768890382, -0.47760768890382, 0.012392311096182, 0.23239231109618, -0.30260768890382, 1.0223923110962},
	[1743] = {1.461409702301, 1.471409702301, 1.251409702301, -0.42859029769898, 0.69140970230102, 0.011409702301018, 0.51640970230102, 1.081409702301, 0.63140970230102},
	[1744] = {1.4444627189636, -0.15553728103638, 0.33446271896363, -0.48553728103638, -0.49553728103638, 0.0044627189636249, 0.47946271896363, -0.32553728103638, 0.16946271896362},
	[1754] = {0.49557060241699, 0.49557060241699, 0.95557060241699, -0.49442939758301, -0.49442939758301, 0.0055706024169938, 0.00057060241699378, 0.00057060241699378, 0.48057060241699},
	[1755] = {1.0630631732941, 0.50306317329406, 1.0830631732941, -0.036936826705935, -0.48693682670594, 0.013063173294065, 0.51306317329406, 0.0080631732940645, 0.54806317329406},
	[1758] = {1.1868629646301, 0.45686296463013, 0.98686296463013, -0.18313703536987, -0.47313703536987, 0.0068629646301269, 0.50186296463013, -0.0081370353698731, 0.49686296463013},
	[1759] = {1.0960325622559, 0.49603256225586, 1.0460325622559, -0.10396743774414, -0.30396743774414, 0.0060325622558609, 0.49603256225586, 0.096032562255861, 0.52603256225586},
	[1762] = {1.1806910896301, 0.49069108963012, 1.0106910896301, -0.18930891036988, -0.47930891036988, 0.00069108963012008, 0.49569108963012, 0.0056910896301201, 0.50569108963012},
	[1765] = {1.0990451908112, 0.50904519081116, 0.97904519081116, -0.060954809188842, -0.47095480918884, -0.00095480918884241, 0.51904519081116, 0.019045190811158, 0.48904519081116},
	[1767] = {1.2339185905456, 0.49391859054565, 1.0839185905456, -0.20608140945435, -0.47608140945435, 0.0039185905456468, 0.51391859054565, 0.0089185905456468, 0.54391859054565},
	[1769] = {1.1617275714874, 0.50172757148742, 1.0017275714874, -0.18827242851258, -0.45827242851258, 0.0017275714874235, 0.48672757148742, 0.021727571487423, 0.50172757148742},
	[1814] = {1.3341318035126, 0.97413180351258, 0.50413180351258, -0.36586819648743, 0.054131803512575, 0.014131803512575, 0.48413180351258, 0.51413180351258, 0.25913180351258},
	[1815] = {1.1010171747208, 1.0710171747208, 0.49101717472077, -0.058982825279234, -0.068982825279234, 0.0010171747207655, 0.52101717472077, 0.50101717472077, 0.24601717472077},
	[1817] = {1.3330284023285, 0.98302840232849, 0.50302840232849, -0.36697159767151, 0.063028402328493, 0.013028402328493, 0.48302840232849, 0.52302840232849, 0.25802840232849},
	[1818] = {1.2435571670532, 1.2835571670532, 0.50355716705322, -0.25644283294678, -0.23644283294678, 0.02355716705322, 0.49355716705322, 0.52355716705322, 0.26355716705322},
	[1819] = {1.0937516260147, 1.1037516260147, 0.51375162601471, -0.066248373985289, -0.066248373985289, 0.0037516260147109, 0.51375162601471, 0.51875162601471, 0.25875162601471},
	[1820] = {1.0266578149796, 1.0366578149796, 0.49665781497955, -0.033342185020446, -0.023342185020446, 0.016657814979554, 0.49665781497955, 0.50665781497955, 0.25665781497955},
	[1822] = {1.0599239492416, 1.0599239492416, 0.48992394924164, -0.040076050758361, -0.020076050758361, 0.0099239492416395, 0.50992394924164, 0.51992394924164, 0.24992394924164},
	[1823] = {1.0918267297745, 0.98182672977448, 0.49182672977448, -0.068173270225524, 0.031826729774476, 0.021826729774476, 0.51182672977448, 0.50682672977448, 0.25682672977448},
	[2024] = {1.4966299724579, 1.2266299724579, 0.52662997245788, -0.48337002754212, -0.22337002754212, 0.0066299724578763, 0.50662997245788, 0.50162997245788, 0.26662997245788},
	[2046] = {0.430048661232, 0.160048661232, 0.530048661232, -0.409951338768, -0.139951338768, -0.529951338768, 0.010048661231996, 0.010048661231996, 4.8661231995706e-05},
	[2078] = {1.4827787590027, 0.25277875900267, 2.1027787590027, -0.48722124099733, -0.48722124099733, 0.0027787590026663, 0.49777875900267, -0.11722124099733, 1.0527787590027},
	[2081] = {1.1312371969223, 0.9912371969223, 0.5012371969223, -0.1187628030777, 0.021237196922304, 0.021237196922304, 0.5062371969223, 0.5062371969223, 0.2612371969223},
	[2082] = {0.98890812397003, 0.98890812397003, 0.49890812397003, 0.0089081239700329, 0.038908123970033, 0.018908123970033, 0.49890812397003, 0.51390812397003, 0.25890812397003},
	[2083] = {0.98025979518891, 0.85025979518891, 0.49025979518891, 0.030259795188905, 0.1602597951889, 0.00025979518890482, 0.50525979518891, 0.50525979518891, 0.2452597951889},
	[2084] = {0.92942370891571, 0.20942370891571, 0.91942370891571, -0.49057629108429, -0.49057629108429, 0.0094237089157119, 0.21942370891571, -0.14057629108429, 0.46442370891571},
	[2161] = {0.83958070278168, 0.019580702781679, 1.3495807027817, -0.48041929721832, -0.47041929721832, 0.0095807027816789, 0.17958070278168, -0.22541929721832, 0.67958070278168},
	[2162] = {1.2825846099853, 0.012584609985345, 1.3725846099853, -0.48741539001466, -0.47741539001466, 0.012584609985345, 0.39758460998534, -0.23241539001466, 0.69258460998535},
	[2163] = {1.2883809566498, 0.018380956649781, 0.91838095664978, -0.48161904335022, -0.47161904335022, 0.0083809566497806, 0.40338095664978, -0.22661904335022, 0.46338095664978},
	[2164] = {1.2841218852997, 0.024121885299671, 1.8441218852997, -0.48587811470033, -0.46587811470033, 0.014121885299671, 0.39912188529967, -0.22087811470033, 0.92912188529967},
	[2167] = {0.42677416324616, 0.026774163246156, 1.5167741632462, -0.48322583675384, -0.47322583675384, 0.0067741632461563, -0.028225836753844, -0.22322583675384, 0.76177416324616},
	[2191] = {0.96283970832824, 0.50283970832824, 1.8128397083282, -0.46716029167176, -0.08716029167176, 0.0028397083282404, 0.24783970832824, 0.20783970832824, 0.90783970832824},
	[2199] = {0.89075176239012, 0.070751762390122, 1.8207517623901, -0.47924823760988, -0.47924823760988, 0.010751762390122, 0.20575176239012, -0.20424823760988, 0.91575176239012},
	[2200] = {1.7444894218445, 0.15448942184446, 1.8944894218445, -0.47551057815554, -0.47551057815554, 0.004489421844463, 0.63448942184446, -0.16051057815554, 0.94948942184446},
	[2204] = {2.4571198940277, 0.06711989402768, 1.7871198940277, -0.48288010597232, -0.48288010597232, 0.01711989402768, 0.98711989402768, -0.20788010597232, 0.90211989402768},
	[2234] = {1.4640431976318, 0.84404319763184, 0.51404319763184, -0.44595680236816, 0.18404319763184, 0.014043197631836, 0.50904319763184, 0.51404319763184, 0.26404319763184},
	[2235] = {1.2679655838013, 0.87796558380127, 0.50796558380127, -0.24203441619873, 0.13796558380127, 0.007965583801271, 0.51296558380127, 0.50796558380127, 0.25796558380127},
	[2291] = {0.98423076152802, 0.49423076152802, 0.92423076152802, 0.014230761528017, -0.47576923847198, 0.014230761528017, 0.49923076152802, 0.0092307615280167, 0.46923076152802},
	[2292] = {0.50032428264618, 0.49032428264618, 0.89032428264618, -0.48967571735382, -0.47967571735382, 0.010324282646181, 0.0053242826461807, 0.0053242826461808, 0.45032428264618},
	[2295] = {0.44614719867706, 0.48614719867706, 0.52614719867706, -0.44385280132294, -0.47385280132294, 0.0061471986770641, 0.0011471986770641, 0.0061471986770641, 0.26614719867706},
	[2462] = {0.25294536590575, 0.092945365905754, 2.2429453659058, -0.48705463409425, -0.47705463409425, 0.0029453659057542, -0.11705463409425, -0.19205463409425, 1.1229453659058},
	[1663] = {0.31276136398316, 0.36276136398316, 0.34276136398316, -0.28723863601684, -0.30723863601684, -0.45723863601685, 0.012761363983155, 0.027761363983155, -0.057238636016845},
	[1671] = {0.34181984901428, 0.37181984901428, 0.36181984901428, -0.33818015098572, -0.30818015098572, -0.45818015098572, 0.0018198490142832, 0.031819849014283, -0.048180150985717},
	[1704] = {1.0184889316559, 0.49848893165588, 1.0284889316559, -0.10151106834412, -0.48151106834412, 0.0084889316558795, 0.45848893165588, 0.0084889316558795, 0.51848893165588},
	[1705] = {1.0635131072998, 0.5035131072998, 0.8735131072998, -0.056486892700199, -0.4764868927002, 0.003513107299801, 0.5035131072998, 0.013513107299801, 0.4385131072998},
	[1708] = {1.1997622299194, 0.49976222991943, 0.98976222991943, -0.21023777008057, -0.48023777008057, 0.0097622299194261, 0.49476222991943, 0.0097622299194261, 0.49976222991943},
	[1711] = {0.84854343891144, 0.50854343891144, 1.0185434389114, -0.49145656108856, -0.48145656108856, 0.0085434389114392, 0.17854343891144, 0.013543438911439, 0.51354343891144},
	[1723] = {2.4758775520324, 0.49587755203243, 0.85587755203243, -0.45412244796757, -0.47412244796757, 0.18587755203243, 1.0108775520324, 0.010877552032434, 0.52087755203243},
	[1724] = {1.0776468372345, 0.48764683723449, 0.88764683723449, -0.042353162765507, -0.48235316276551, 0.0076468372344927, 0.51764683723449, 0.0026468372344927, 0.44764683723449},
	[1726] = {2.1735367202758, 0.50353672027585, 0.92353672027585, -0.16646327972415, -0.46646327972415, 0.18353672027585, 1.0035367202758, 0.018536720275848, 0.55353672027585},
	[1735] = {0.44298279285431, 0.45298279285431, 1.2729827928543, -0.41701720714569, -0.46701720714569, 0.0029827928543106, 0.012982792854311, -0.0070172071456895, 0.63798279285431},
	[1806] = {0.28348519325256, 0.41348519325256, 0.49348519325256, -0.26651480674744, -0.12651480674744, -0.016514806747435, 0.0084851932525647, 0.14348519325256, 0.23848519325256},
	[1811] = {0.38131941318512, 0.34131941318512, 0.64131941318512, -0.36868058681488, -0.32868058681488, -0.61868058681488, 0.0063194131851209, 0.0063194131851209, 0.011319413185121},
	[1998] = {1.5120480728149, 1.4920480728149, 1.2620480728149, -0.47795192718508, -0.48795192718508, 0.0020480728149207, 0.51704807281492, 0.50204807281492, 0.63204807281492},
	[1999] = {1.4988937950134, 0.48889379501342, 1.1288937950134, -0.49110620498658, -0.16110620498658, 0.37889379501342, 0.50389379501342, 0.16389379501342, 0.75389379501342},
	[2096] = {0.24198917388916, 0.45198917388916, 0.95198917388916, -0.23801082611084, -0.25801082611084, 0.0019891738891612, 0.0019891738891612, 0.096989173889161, 0.47698917388916},
	[2173] = {1.4856037330627, 0.45560373306274, 0.79560373306274, -0.46439626693726, -0.074396266937263, 0.0056037330627366, 0.51060373306274, 0.19060373306274, 0.40060373306274},
	[2180] = {1.4669234848022, 0.37692348480224, 0.79692348480224, -0.49307651519776, -0.48307651519776, 0.0069234848022415, 0.48692348480224, -0.053076515197758, 0.40192348480224},
	[2184] = {2.5686303424835, 1.1586303424835, 0.76863034248349, -0.48136965751651, -0.48136965751651, 0.0086303424834889, 1.0436303424835, 0.33863034248349, 0.38863034248349},
	[2206] = {2.3609004211425, 0.50090042114256, 0.93090042114256, -0.48909957885745, -0.47909957885745, 0.010900421142555, 0.93590042114255, 0.010900421142555, 0.47090042114256},
	[2311] = {1.9681643199921, 0.47816431999205, 0.49816431999205, -0.45183568000795, -0.46183568000795, 0.0081643199920532, 0.75816431999205, 0.0081643199920532, 0.25316431999205},
	[2313] = {1.8455816745758, 0.4755816745758, 0.4955816745758, -0.4644183254242, -0.4644183254242, 0.0055816745757956, 0.6905816745758, 0.0055816745757956, 0.2505816745758},
	[2314] = {1.9641347599029, 0.43413475990294, 0.49413475990294, -0.43586524009706, -0.40586524009706, 0.004134759902943, 0.76413475990294, 0.014134759902943, 0.24913475990294},
	[2315] = {1.9510251045227, 0.48102510452269, 0.49102510452269, -0.45897489547731, -0.45897489547731, 0.011025104522693, 0.74602510452269, 0.011025104522693, 0.25102510452269},
	[2319] = {1.9842331695557, 0.47423316955565, 0.49423316955565, -0.42576683044435, -0.45576683044435, 0.054233169555649, 0.77923316955565, 0.0092331695556489, 0.27423316955565},
	[2321] = {1.9708479499817, 0.49084794998168, 0.49084794998168, -0.42915205001832, -0.45915205001832, 0.010847949981678, 0.77084794998168, 0.015847949981678, 0.25084794998168},
	[2346] = {1.1678630971909, 0.48786309719086, 0.48786309719086, -0.15213690280914, -0.39213690280914, 0.0078630971908583, 0.50786309719086, 0.047863097190858, 0.24786309719086},
	[2370] = {1.1344808483124, 1.2044808483124, 0.84448084831237, -0.48551915168763, -0.48551915168763, 0.014480848312369, 0.32448084831237, 0.35948084831237, 0.42948084831237},
	[11665] = {1.5847433853149, 1.5047433853149, 0.70474338531487, -1.5852566146851, -1.4952566146851, -0.68525661468513, -0.00025661468512717, 0.0047433853148728, 0.0097433853148729},
	[2699] = {0.74435527801513, 0.78435527801513, 0.62435527801513, -0.73564472198487, -0.76564472198487, -0.61564472198487, 0.004355278015126, 0.009355278015126, 0.004355278015126},
	[1235] = {0.32034210681915, 0.33034210681915, 0.46034210681915, -0.31965789318085, -0.27965789318085, -0.49965789318085, 0.00034210681915389, 0.025342106819154, -0.019657893180846},
	[1429] = {0.36561310768128, 0.26561310768128, 0.25561310768128, -0.33438689231872, -0.23438689231872, -0.24438689231872, 0.015613107681275, 0.015613107681275, 0.0056131076812752},
	[1747] = {0.088749401569367, -0.041250598430633, 0.42874940156937, -0.48125059843063, -0.47125059843063, 0.0087494015693671, -0.19625059843063, -0.25625059843063, 0.21874940156937},
	[1748] = {0.1490779709816, -0.1509220290184, 0.4590779709816, -0.4909220290184, -0.4809220290184, 0.0090779709815985, -0.1709220290184, -0.3159220290184, 0.2340779709816},
	[1749] = {0.097383384704591, 0.12738338470459, 0.56738338470459, -0.49261661529541, -0.48261661529541, 0.0073833847045906, -0.19761661529541, -0.17761661529541, 0.28738338470459},
	[1750] = {0.2117867398262, -0.078213260173797, 0.5217867398262, -0.4882132601738, -0.4782132601738, 0.011786739826203, -0.1382132601738, -0.2782132601738, 0.2667867398262},
	[1751] = {0.2240015077591, -0.075998492240905, 0.5540015077591, -0.48599849224091, -0.48599849224091, 0.004001507759095, -0.13099849224091, -0.28099849224091, 0.2790015077591},
	[1752] = {0.37175250530243, 0.06175250530243, 0.72175250530243, -0.48824749469757, -0.48824749469757, 0.01175250530243, -0.05824749469757, -0.21324749469757, 0.36675250530243},
	[1781] = {0.19700650930405, -0.13299349069595, 0.46700650930405, -0.49299349069595, -0.48299349069595, 0.0070065093040473, -0.14799349069595, -0.30799349069595, 0.23700650930405},
	[1791] = {0.21136058807373, 0.0013605880737312, 0.56136058807373, -0.39863941192627, -0.38863941192627, 0.0013605880737312, -0.093639411926269, -0.19363941192627, 0.28136058807373},
	[1792] = {0.66954239368439, -0.040457606315612, 0.88954239368439, -0.49045760631561, -0.48045760631561, 0.0095423936843884, 0.089542393684388, -0.26045760631561, 0.44954239368439},
	[2296] = {2.4747437763214, 0.29474377632137, 2.4847437763214, -0.48525622367863, -0.48525622367863, 0.0047437763213712, 0.99474377632137, -0.095256223678629, 1.2447437763214},
	[2297] = {1.4866965484619, 1.4966965484619, 1.6966965484619, -0.4633034515381, -0.4633034515381, 0.016696548461898, 0.5116965484619, 0.5166965484619, 0.8566965484619},
	[14532] = {0.41999500274658, 0.34999500274658, 0.97999500274658, -0.41000499725342, -0.36000499725342, -0.98000499725342, 0.0049950027465781, -0.0050049972534219, -4.9972534219012e-06},
	[1719] = {0.29489696979523, 0.20489696979523, 0.10489696979523, -0.27510303020477, -0.17510303020477, -0.045103030204772, 0.0098969697952276, 0.014896969795228, 0.029896969795228},
	[2028] = {0.23582397937775, 0.27582397937775, 0.085823979377747, -0.23417602062225, -0.24417602062225, -0.074176020622253, 0.00082397937774711, 0.015823979377747, 0.0058239793777471},
	[2421] = {0.16839884281159, 0.048398842811585, 0.43839884281159, -0.47160115718842, -0.47160115718842, 0.0083988428115852, -0.15160115718841, -0.21160115718841, 0.22339884281159},
	[2149] = {0.26971881628037, 0.19971881628037, 0.16971881628037, -0.23028118371963, -0.17028118371963, -0.15028118371963, 0.019718816280366, 0.014718816280366, 0.0097188162803655},
	[2229] = {-0.12439903259277, 0.0056009674072278, 1.3956009674072, -0.48439903259277, -0.49439903259277, 0.0056009674072278, -0.30439903259277, -0.24439903259277, 0.70060096740723},
	[2230] = {-0.12502093315124, -0.035020933151244, 1.2949790668488, -0.48502093315124, -0.49502093315124, 0.004979066848756, -0.30502093315124, -0.26502093315124, 0.64997906684876},
	[2231] = {-0.0015021514892569, -0.041502151489257, 0.89849784851074, -0.49150215148926, -0.49150215148926, 0.0084978485107431, -0.24650215148926, -0.26650215148926, 0.45349784851074},
	[2232] = {0.36141125679016, 0.35141125679016, 0.60141125679016, -0.33858874320984, -0.33858874320984, -0.58858874320984, 0.011411256790162, 0.0064112567901624, 0.0064112567901624},
	[2233] = {-0.25640189647674, -0.25640189647674, 1.2035981035233, -0.49640189647674, -0.48640189647674, 0.0035981035232554, -0.37640189647674, -0.37140189647674, 0.60359810352326},
	[2099] = {0.73912501335144, -0.00087498664855814, 0.94912501335144, -0.49087498664856, -0.49087498664856, 0.0091250133514419, 0.12412501335144, -0.24587498664856, 0.47912501335144},
	[2100] = {0.95316751480102, 0.10316751480102, 1.073167514801, -0.48683248519898, -0.48683248519898, 0.0031675148010192, 0.23316751480102, -0.19183248519898, 0.53816751480102},
	[2101] = {0.2721282863617, 0.2421282863617, 0.5421282863617, -0.27787171363831, -0.21787171363831, 0.002128286361695, -0.002871713638305, 0.012128286361695, 0.2721282863617},
	[2226] = {0.42379854679108, 0.14379854679108, 0.32379854679108, -0.39620145320892, -0.12620145320892, 0.0037985467910774, 0.013798546791077, 0.0087985467910774, 0.16379854679108},
	[2225] = {0.19604564189911, -0.06395435810089, 0.85604564189911, -0.48395435810089, -0.48395435810089, 0.0060456418991098, -0.14395435810089, -0.27395435810089, 0.43104564189911},
	[2227] = {-0.055126304626464, -0.22512630462646, 1.0548736953735, -0.48512630462646, -0.48512630462646, 0.0048736953735361, -0.27012630462646, -0.35512630462646, 0.52987369537354},
	[1782] = {0.32324638366699, 0.24324638366699, 0.083246383666993, -0.31675361633301, -0.21675361633301, -0.076753616333007, 0.0032463836669928, 0.013246383666993, 0.0032463836669928},
	[1783] = {0.33311720132828, 0.23311720132828, 0.073117201328278, -0.31688279867172, -0.20688279867172, -0.066882798671722, 0.0081172013282782, 0.013117201328278, 0.0031172013282782},
	[1785] = {0.33162852525711, 0.23162852525711, 0.11162852525711, -0.30837147474289, -0.20837147474289, -0.098371474742889, 0.011628525257111, 0.011628525257111, 0.0066285252571112},
	[1787] = {0.32884950876236, 0.23884950876236, 0.06884950876236, -0.32115049123764, -0.21115049123764, -0.06115049123764, 0.0038495087623602, 0.01384950876236, 0.0038495087623602},
	[1790] = {0.33312226772308, 0.23312226772308, 0.073122267723084, -0.31687773227692, -0.20687773227692, -0.066877732276916, 0.0081222677230841, 0.013122267723084, 0.0031222677230841},
	[2190] = {0.042838506698609, -0.047161493301391, 0.54283850669861, -0.48716149330139, -0.47716149330139, 0.012838506698609, -0.22216149330139, -0.26216149330139, 0.27783850669861},
	[2238] = {0.13447372913361, 0.14447372913361, 0.41447372913361, -0.13552627086639, -0.12552627086639, -0.40552627086639, -0.00052627086639337, 0.0094737291336066, 0.0044737291336066},
	[2196] = {-0.15094552993774, -0.34094552993774, 0.37905447006226, -0.49094552993774, -0.48094552993774, 0.0090544700622562, -0.32094552993774, -0.41094552993774, 0.19405447006226},
	[2726] = {0.10131320953369, 0.11131320953369, 0.34131320953369, -0.098686790466308, -0.088686790466308, -0.33868679046631, 0.0013132095336919, 0.011313209533692, 0.0013132095336919},
	[2109] = {0.85525788307189, 0.84525788307189, 0.41525788307189, -0.84474211692811, -0.83474211692811, -0.38474211692811, 0.0052578830718897, 0.0052578830718897, 0.01525788307189},
	[2111] = {0.85785785675048, 0.83785785675048, 0.46785785675048, -0.84214214324952, -0.83214214324952, -0.38214214324952, 0.0078578567504782, 0.0028578567504782, 0.042857856750478},
	[2112] = {0.70216523170471, 0.69216523170471, 0.47216523170471, -0.69783476829529, -0.68783476829529, -0.38783476829529, 0.0021652317047103, 0.0021652317047103, 0.04216523170471},
	[2031] = {1.4812674999237, 0.4812674999237, 0.7912674999237, -0.4587325000763, -0.4687325000763, 0.011267499923701, 0.5112674999237, 0.0062674999237011, 0.4012674999237},
	[2030] = {0.85549820899962, 0.83549820899962, 0.40549820899962, -0.84450179100038, -0.83450179100038, -0.39450179100038, 0.0054982089996241, 0.00049820899962411, 0.0054982089996241},
	[2029] = {1.4996019363403, 0.48960193634033, 0.79960193634033, -0.47039806365967, -0.48039806365967, -0.00039806365967379, 0.51460193634033, 0.0046019363403262, 0.39960193634033},
	[1770] = {1.4859417152405, 0.49594171524047, 0.79594171524047, -0.46405828475953, -0.48405828475953, 0.0059417152404731, 0.51094171524047, 0.0059417152404731, 0.40094171524047},
	[936] = {0.95271669387817, 0.59271669387817, 0.47271669387817, -0.92728330612183, -0.54728330612183, -0.46728330612183, 0.012716693878167, 0.022716693878167, 0.0027166938781669},
	[937] = {0.94531476974487, 0.61531476974487, 0.47531476974487, -0.92468523025514, -0.58468523025513, -0.47468523025513, 0.010314769744866, 0.015314769744866, 0.00031476974486552},
	[941] = {1.4307565689087, 0.61075656890868, 0.47075656890868, -0.91924343109132, -0.57924343109132, -0.46924343109132, 0.25575656890868, 0.015756568908676, 0.00075656890867579},
	[1821] = {1.0310313129425, 0.78103131294251, 0.71103131294251, -0.038968687057494, 0.24103131294251, 0.011031312942506, 0.49603131294251, 0.51103131294251, 0.36103131294251},
	[2014] = {0.49479846954345, 0.49479846954345, 2.2947984695434, -0.49520153045655, -0.49520153045655, 0.15479846954345, -0.00020153045655305, -0.00020153045655305, 1.2247984695434},
	[2015] = {0.49813931465148, 0.49813931465148, 2.2881393146515, -0.49186068534852, -0.49186068534852, 0.0081393146514764, 0.0031393146514764, 0.0031393146514764, 1.1481393146515},
	[2016] = {0.49734681129454, 0.49734681129454, 2.2873468112945, -0.49265318870546, -0.49265318870546, 0.0073468112945428, 0.0023468112945428, 0.0023468112945428, 1.1473468112945},
	[2018] = {0.49727743148802, 0.49727743148802, 2.287277431488, -0.49272256851198, -0.49272256851198, 0.0072774314880242, 0.0022774314880243, 0.0022774314880243, 1.147277431488},
	[2019] = {0.49732130050658, 0.49732130050658, 2.2873213005066, -0.49267869949342, -0.49267869949342, 0.0073213005065789, 0.0023213005065789, 0.0023213005065789, 1.1473213005066},
	[2020] = {1.4733616352081, 0.98336163520812, 1.3533616352081, -0.46663836479188, 0.49336163520812, 0.0033616352081226, 0.50336163520812, 0.73836163520812, 0.67836163520812},
	[2021] = {0.46829795360565, 1.3982979536057, 0.89829795360565, -0.47170204639435, 0.99829795360565, 0.008297953605653, -0.001702046394347, 1.1982979536057, 0.45329795360565},
	[2022] = {0.49341254234313, 0.49341254234313, 2.2934125423431, -0.49658745765687, -0.49658745765687, 0.15341254234313, -0.0015874576568704, -0.0015874576568704, 1.2234125423431},
	[2128] = {0.49980023384093, 0.49980023384093, 2.1898002338409, -0.49019976615907, -0.25019976615907, 0.0098002338409327, 0.0048002338409327, 0.12480023384093, 1.0998002338409},
	[2129] = {0.5009265232086, 0.5009265232086, 2.2009265232086, -0.4890734767914, -0.2490734767914, 0.010926523208598, 0.005926523208598, 0.1259265232086, 1.1059265232086},
	[2133] = {0.50807575702667, 0.50807575702667, 1.0480757570267, -0.48192424297333, -0.29192424297333, 0.0080757570266737, 0.013075757026674, 0.10807575702667, 0.52807575702667},
	[2134] = {0.49805274963379, 0.49805274963379, 1.0480527496338, -0.49194725036621, -0.30194725036621, 0.0080527496337904, 0.0030527496337904, 0.09805274963379, 0.52805274963379},
	[2137] = {0.50911289215086, 0.49911289215086, 2.7891128921508, -0.47088710784914, -0.20088710784914, 0.0091128921508582, 0.019112892150858, 0.14911289215086, 1.3991128921509},
	[2138] = {0.49910907745359, 0.49910907745359, 2.7891090774536, -0.48089092254641, -0.20089092254641, 0.0091090774535925, 0.0091090774535925, 0.14910907745359, 1.3991090774536},
	[2139] = {0.50768804073334, 0.50768804073334, 1.0576880407333, -0.47231195926666, -0.19231195926666, 0.017688040733339, 0.017688040733339, 0.15768804073334, 0.53768804073334},
	[2140] = {0.51098102569576, 0.50098102569576, 3.9809810256957, -0.46901897430424, -0.18901897430424, -0.0090189743042438, 0.020981025695756, 0.15598102569576, 1.9859810256957},
	[2141] = {0.49822874069209, 0.49822874069209, 3.9782287406921, -0.49177125930791, -0.30177125930791, -0.011771259307907, 0.0032287406920934, 0.098228740692094, 1.9832287406921},
	[2142] = {0.87361371517182, 0.23361371517182, 1.0436137151718, -0.48638628482818, -0.48638628482818, 0.0036137151718155, 0.19361371517182, -0.12638628482818, 0.52361371517182},
	[2143] = {1.0208323097229, 0.2308323097229, 1.0508323097229, -0.4891676902771, -0.4791676902771, 0.010832309722902, 0.2658323097229, -0.1241676902771, 0.5308323097229},
	[2145] = {0.21268600463865, 0.23268600463865, 2.7926860046386, -0.48731399536135, -0.48731399536135, 0.0026860046386528, -0.13731399536135, -0.12731399536135, 1.3976860046386},
	[2151] = {0.88132440567014, 0.23132440567014, 1.0513244056701, -0.48867559432986, -0.48867559432986, 0.0013244056701414, 0.19632440567014, -0.12867559432986, 0.52632440567014},
	[2152] = {0.87565898895264, 0.22565898895264, 1.0456589889526, -0.48434101104736, -0.48434101104736, 0.0056589889526382, 0.19565898895264, -0.12934101104736, 0.52565898895264},
	[2153] = {0.21122344017028, 0.23122344017028, 2.4112234401703, -0.48877655982972, -0.48877655982972, 0.0012234401702767, -0.13877655982972, -0.12877655982972, 1.2062234401703},
	[2154] = {0.87887804031372, 0.22887804031372, 1.0488780403137, -0.49112195968628, -0.48112195968628, 0.0088780403137215, 0.19387804031372, -0.12612195968628, 0.52887804031372},
	[2155] = {0.32771501541138, 0.22771501541138, 1.0477150154114, -0.49228498458862, -0.48228498458862, 0.0077150154113782, -0.082284984588622, -0.12728498458862, 0.52771501541138},
	[2156] = {0.88032179832459, 0.22032179832459, 1.1503217983246, -0.48967820167541, -0.48967820167541, 0.010321798324587, 0.19532179832459, -0.13467820167541, 0.58032179832459},
	[2157] = {0.8803216791153, 0.2203216791153, 1.1503216791153, -0.4896783208847, -0.4896783208847, 0.010321679115297, 0.1953216791153, -0.1346783208847, 0.5803216791153},
	[2158] = {0.50633090972896, 0.50633090972896, 3.9963309097289, -0.48366909027104, -0.19366909027104, 0.0063309097289591, 0.011330909728959, 0.15633090972896, 2.0013309097289},
	[2159] = {0.87773722171784, 0.21773722171784, 1.1477372217178, -0.49226277828216, -0.48226277828216, 0.0077372217178361, 0.19273722171784, -0.13226277828216, 0.57773722171784},
	[2160] = {0.87354099273682, 0.21354099273682, 1.1435409927368, -0.48645900726318, -0.48645900726318, 0.0035409927368183, 0.19354099273682, -0.13645900726318, 0.57354099273682},
	[2303] = {0.50768804073334, 0.49768804073334, 1.0476880407333, -0.47231195926666, -0.21231195926666, 0.0076880407333387, 0.017688040733339, 0.14268804073334, 0.52768804073334},
	[2304] = {0.4900053501129, 0.4900053501129, 2.1900053501129, -0.4899946498871, -0.4899946498871, 0.010005350112904, 5.3501129038958e-06, 5.3501129038958e-06, 1.1000053501129},
	[2305] = {0.50231087684629, 0.50231087684629, 2.7923108768463, -0.47768912315371, -0.47768912315371, 0.0023108768462913, 0.012310876846291, 0.012310876846291, 1.3973108768463},
	[2334] = {0.50794053077698, 0.50794053077698, 1.057940530777, -0.48205946922302, -0.19205946922302, -0.0020594692230211, 0.012940530776979, 0.15794053077698, 0.52794053077698},
	[2335] = {0.50283906936646, 0.51283906936646, 1.0528390693665, -0.48716093063354, -0.19716093063354, 0.012839069366456, 0.0078390693664565, 0.15783906936646, 0.53283906936646},
	[2338] = {0.49018151283264, 0.49018151283264, 1.1701815128326, -0.48981848716736, -0.48981848716736, 0.010181512832643, 0.00018151283264309, 0.00018151283264309, 0.59018151283264},
	[2341] = {0.50729336261749, 0.49729336261749, 1.0472933626175, -0.48270663738251, -0.49270663738251, 0.0072933626174941, 0.012293362617494, 0.0022933626174941, 0.52729336261749},
	[1432] = {1.114647026062, 1.184647026062, 0.76464702606199, -1.065352973938, -0.75535297393801, -0.12535297393801, 0.024647026061992, 0.21464702606199, 0.31964702606199},
	[1433] = {0.59018682956696, 0.58018682956696, 0.50018682956696, -0.55981317043304, -0.56981317043304, -0.16981317043304, 0.015186829566957, 0.005186829566957, 0.16518682956696},
	[1594] = {1.1613999462128, 1.0613999462128, 0.47139994621276, -1.1586000537872, -1.0486000537872, -0.46860005378724, 0.0013999462127554, 0.0063999462127554, 0.0013999462127555},
	[1720] = {0.25031175136566, 0.48031175136566, 1.0003117513657, -0.22968824863434, -0.11968824863434, 0.010311751365663, 0.010311751365663, 0.18031175136566, 0.50531175136566},
	[1721] = {0.29697140216828, 0.42697140216828, 0.49697140216828, -0.26302859783173, -0.12302859783172, -0.013028597831725, 0.016971402168275, 0.15197140216828, 0.24197140216828},
	[1805] = {0.22950916290283, 0.22950916290283, 0.25950916290283, -0.22049083709717, -0.21049083709717, -0.24049083709717, 0.0045091629028326, 0.0095091629028326, 0.0095091629028326},
	[1810] = {-0.0059307479858389, 0.47406925201416, 0.91406925201416, -0.45593074798584, -0.075930747985839, 0.0040692520141611, -0.23093074798584, 0.19906925201416, 0.45906925201416},
	[2079] = {0.26949799060822, 0.25949799060822, 0.63949799060822, -0.25050200939178, -0.24050200939178, -0.63050200939178, 0.0094979906082165, 0.0094979906082165, 0.0044979906082165},
	[2120] = {0.37440583229065, 0.30440583229065, 0.64440583229065, -0.34559416770935, -0.29559416770935, -0.63559416770935, 0.014405832290651, 0.0044058322906507, 0.0044058322906507},
	[2121] = {0.26614662647247, 0.31614662647247, 0.51614662647247, -0.24385337352753, -0.30385337352753, -0.50385337352753, 0.011146626472474, 0.0061466264724742, 0.0061466264724742},
	[2124] = {0.24586314678192, 0.27586314678192, 0.82586314678192, -0.23413685321808, -0.27413685321808, -0.82413685321808, 0.0058631467819229, 0.00086314678192287, 0.00086314678192284},
	[2125] = {0.26110883712769, 0.26110883712769, 0.31110883712769, -0.22889116287231, -0.23889116287231, -0.30889116287231, 0.016108837127686, 0.011108837127686, 0.0011088371276863},
	[2350] = {0.22924497842789, 0.22924497842789, 0.37924497842789, -0.21075502157211, -0.22075502157211, -0.37075502157211, 0.0092449784278877, 0.0042449784278877, 0.0042449784278877},
	[2636] = {0.24210950374603, 0.28210950374603, -0.10789049625397, -0.20789049625397, -0.22789049625397, -0.61789049625397, 0.017109503746034, 0.027109503746034, -0.36289049625397},
	[2637] = {1.0521236801147, 0.64212368011474, 0.40212368011474, -1.0278763198853, -0.59787631988527, -0.39787631988526, 0.012123680114735, 0.022123680114735, 0.0021236801147354},
	[2644] = {0.51983422279358, 0.53983422279358, 0.41983422279358, -0.47016577720642, -0.50016577720642, -0.40016577720642, 0.02483422279358, 0.01983422279358, 0.0098342227935805},
	[2762] = {1.061200428009, 0.55120042800902, 0.41120042800902, -1.018799571991, -0.50879957199098, -0.39879957199098, 0.021200428009025, 0.021200428009025, 0.0062004280090246},
	[2763] = {0.54688311576843, 0.55688311576843, 0.41688311576843, -0.50311688423157, -0.50311688423157, -0.40311688423157, 0.021883115768434, 0.026883115768434, 0.006883115768434},
	[2764] = {0.54607323646546, 0.56607323646546, 0.41607323646546, -0.50392676353454, -0.53392676353454, -0.40392676353454, 0.021073236465456, 0.016073236465455, 0.0060732364654555},
	[2788] = {0.20274688243866, 0.24274688243866, -0.0072531175613392, -0.28725311756134, -0.24725311756134, -0.52725311756134, -0.042253117561339, -0.0022531175613392, -0.26725311756134},
	[15036] = {2.5002476310729, 1.5002476310729, 1.1502476310729, -2.4897523689271, -1.4897523689271, -1.1397523689271, 0.0052476310728735, 0.0052476310728738, 0.0052476310728738},
	[2294] = {0.50365617752073, 0.50365617752073, 2.1936561775207, -0.49634382247927, -0.26634382247927, 0.013656177520732, 0.0036561775207318, 0.11865617752073, 1.1036561775207},
	[2336] = {1.5060320472717, 0.50603204727172, 1.0560320472717, -0.48396795272828, -0.20396795272828, 0.0060320472717184, 0.51103204727172, 0.15103204727172, 0.53103204727172},
	[2337] = {0.50803197383881, 0.50803197383881, 1.0480319738388, -0.48196802616119, -0.24196802616119, 0.018031973838808, 0.013031973838808, 0.13303197383881, 0.53303197383881},
	[2339] = {0.49805012702942, 0.49805012702942, 1.0480501270294, -0.49194987297058, -0.30194987297058, 0.0080501270294203, 0.0030501270294203, 0.09805012702942, 0.52805012702942},
	[2340] = {0.49804619312287, 0.49804619312287, 1.0480461931229, -0.49195380687714, -0.30195380687714, 0.0080461931228651, 0.0030461931228651, 0.098046193122865, 0.52804619312287},
	[2127] = {1.4930954551697, 0.50309545516966, 2.1930954551697, -0.48690454483034, -0.25690454483034, 0.0030954551696568, 0.50309545516966, 0.12309545516966, 1.0980954551697},
	[2131] = {1.5098343467712, 0.49983434677119, 3.9998343467711, -0.48016565322881, -0.30016565322881, 0.0098343467711875, 0.51483434677119, 0.099834346771188, 2.0048343467712},
	[2132] = {1.5019399929047, 0.50193999290465, 1.2119399929047, -0.48806000709535, -0.28806000709535, 0.0019399929046547, 0.50693999290466, 0.10693999290465, 0.60693999290466},
	[2135] = {0.4983947753906, 0.4983947753906, 2.7883947753906, -0.4816052246094, -0.2116052246094, 0.0083947753906043, 0.0083947753906043, 0.1433947753906, 1.3983947753906},
	[2136] = {1.499031381607, 0.49903138160705, 1.049031381607, -0.47096861839296, -0.21096861839296, -0.00096861839295506, 0.51403138160705, 0.14403138160705, 0.52403138160705},
	[2147] = {0.48876279830928, 0.49876279830928, 3.9987627983092, -0.47123720169072, -0.32123720169072, 0.0087627983092809, 0.0087627983092809, 0.088762798309281, 2.0037627983093},
	[2516] = {1.7530589199066, 0.49305891990661, 0.58305891990661, -0.46694108009339, -0.47694108009339, 0.0030589199066072, 0.64305891990661, 0.0080589199066072, 0.29305891990661},
	[2517] = {0.63784890174865, 1.4978489017486, 2.1578489017486, -0.46215109825136, 0.39784890174865, 0.0078489017486448, 0.087848901748645, 0.94784890174865, 1.0828489017486},
	[2518] = {0.82915793895722, 0.50915793895722, 1.1591579389572, 0.19915793895722, 0.049157938957215, 0.41915793895722, 0.51415793895722, 0.27915793895722, 0.78915793895722},
	[2519] = {1.7620001029968, 0.49200010299682, 0.58200010299682, -0.46799989700318, -0.47799989700318, 0.0020001029968172, 0.64700010299682, 0.0070001029968172, 0.29200010299682},
	[2520] = {0.62147674560546, 1.4914767456055, 2.2614767456055, -0.44852325439455, 0.41147674560546, 0.011476745605455, 0.086476745605455, 0.95147674560546, 1.1364767456055},
	[2521] = {0.21559812545776, 0.50559812545776, 1.0455981254578, -0.19440187454224, -0.14440187454224, 0.015598125457765, 0.010598125457765, 0.18059812545776, 0.53059812545776},
	[2522] = {1.7998039722442, 0.49980397224424, 1.9898039722442, -0.48019602775576, -0.48019602775576, 0.0098039722442388, 0.65980397224424, 0.0098039722442388, 0.99980397224424},
	[2523] = {0.80305683135986, 0.51305683135986, 1.0230568313599, 0.21305683135986, -0.046943168640136, 0.0030568313598643, 0.50805683135986, 0.23305683135986, 0.51305683135986},
	[2524] = {0.7690206861496, 0.4990206861496, 1.0190206861496, 0.2090206861496, 0.1090206861496, 0.0090206861495981, 0.4890206861496, 0.3040206861496, 0.5140206861496},
	[2525] = {0.25851140975952, 0.49851140975952, 1.0785114097595, -0.23148859024048, -0.12148859024048, 0.0085114097595225, 0.013511409759523, 0.18851140975952, 0.54351140975952},
	[2526] = {1.7283613586426, 0.49836135864257, 0.71836135864257, -0.46163864135743, -0.46163864135743, 0.0083613586425689, 0.63336135864257, 0.018361358642569, 0.36336135864257},
	[2527] = {0.60985330581664, 1.4898533058166, 1.8798533058166, -0.47014669418336, 0.39985330581664, 0.0098533058166429, 0.069853305816643, 0.94485330581664, 0.94485330581664},
	[2528] = {0.29673346042633, 0.49673346042633, 0.93673346042633, -0.28326653957367, -0.36326653957367, 0.0067334604263317, 0.0067334604263317, 0.066733460426332, 0.47173346042633},
	[1778] = {0.042571930885316, -0.12742806911468, 0.25257193088532, -0.37742806911468, -0.35742806911468, 0.0025719308853161, -0.16742806911468, -0.24242806911468, 0.12757193088532},
	--[[tv1]][2648] = {0.12043422698974, 0.99043422698974, 0.56043422698974, -0.11956577301026, -0.99956577301026, -0.56956577301026, 0.00043422698974113, -0.0045657730102589, -0.0045657730102589},
	--[[tv2]][14772] = {0.060595560073849, 0.99059556007385, 0.49059556007385, -0.059404439926151, -0.99940443992615, -0.49940443992615, 0.00059556007384929, -0.0044044399261507, -0.0044044399261507},
	--[[urma4k]][1786] = {0.062710914611726, 2.8727109146117, 1.3327109146117, -0.067289085388274, -2.8672890853883, -1.3272890853883, -0.0022890853882745, 0.0027109146117252, 0.0027109146117255},
	--[[széf]][2332] = {0.43313296794892, 0.43313296794892, 0.46313296794892, -0.41686703205109, -0.40686703205109, -0.45686703205109, 0.0081329679489148, 0.013132967948915, 0.0031329679489148},
	--[[billiárd]][2964] = {1.1333254146576, 0.68332541465757, 0.94332541465758, -1.1166745853424, -0.65667458534243, 0.013325414657574, 0.0083254146575743, 0.013325414657574, 0.47832541465757},
}

local availableFurnitures = {
	["Háló"] = {
		2069, 2023, 1416, 1417, 1740, 1741, 1816, 2025, 2087, 2088, 2089, 2094, 2095, 2200, 2307,
		2323, 2328, 2329, 2330, 2576, 2708, 1700, 1701, 1745, 1793, 1794, 1795, 1796, 1797, 1798,
		1799, 1800, 1801, 1802, 1803, 1812, 2090, 2298, 2299, 2300, 2301, 2302, 2331, 2333, 2563,
		2564, 2565, 2566, 2575, 14446
	},
	["Nappali"] = {
		2571, 2357, 2290, 2239, 2119, 2118, 2117, 2116, 2115, 2109, 2111, 2112, 2108, 1768, 1766,
		1764, 1763, 1761, 1760, 1757, 1756, 1753, 1713, 1712, 1710, 1709, 1707, 1706, 1703, 1702,
		1742, 1743, 1744, 1754, 1755, 1758, 1759, 1762, 1765, 1767, 1769, 1814, 1815, 1817, 1818,
		1819, 1820, 1822, 1823, 2024, 2046, 2078, 2081, 2082, 2083, 2084, 2161, 2162, 2163, 2164,
		2167, 2191, 2199, 2200, 2204, 2234, 2235, 2291, 2292, 2295, 2462, 1663, 1671, 1704, 1705,
		1708, 1711, 1723, 1724, 1726, 1735, 1806, 1811, 1998, 1999, 2096, 2173, 2180, 2184, 2206,
		2311, 2313, 2314, 2315, 2319, 2321, 2346, 2370, 11665, 2699, 1235
	},
	["Fürdő"] = {
		2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 1778
	},
	["Konyha, étkező"] = {
		2109, 2111, 2112, 2031, 2030, 2029, 1770, 936, 937, 941, 1821, 2014, 2015, 2016, 2018,
		2019, 2020, 2021, 2022, 2128, 2129, 2133, 2134, 2137, 2138, 2139, 2140, 2141, 2142, 2143,
		2145, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2303, 2304, 2305, 2334,
		2335, 2338, 2341, 1432, 1433, 1594, 1720, 1721, 1805, 1810, 2079, 2120, 2121, 2124, 2125,
		2350, 2636, 2637, 2644, 2762, 2763, 2764, 2788, 2802, 15036, 2294, 2336, 2337, 2339, 2340,
		2127, 2131, 2132, 2135, 2136, 2147
	},
	["Elektronika"] = {
		1429, 1747, 1748, 1749, 1750, 1751, 1752, 1781, 1791, 1792, 2296, 2297, 14532, 1719, 2028,
		2421, 2149, 2229, 2230, 2231, 2232, 2233, 2099, 2100, 2101, 2226, 2225, 2227, 1782, 1783,
		1785, 1787, 1790, 2190, 2238, 2196, 2726
	},
	["Dekoráció"] = {
		2724, 2725, 3383, 16151, 2224, 2452, 2627, 2630, 2628, 2629, 2916, 2915, 1585, 1584, 1583,
		2484, 2491, 2489, 2490, 2500, 2581, 2584, 1775, 1776, 2743, 1369, 3065, 1985, 3461, 3534,
		3385, 2976, 1829, 2778, 2779, 2872, 630, 631, 632, 633, 638, 646, 948, 949, 950, 1361, 2001,
		2010, 2011, 2194, 2195, 2240, 2241, 2244, 2251, 2252, 2253, 2811, 14834
	},
	["Prémium"] = {
		2332, 2648, 14772, 1786, 2964
	}
}

for k, v in pairs(availableFurnitures) do
	for i = 1, #v do
		engineSetModelLODDistance(v[i], 300)
	end
end

local activeFurniture = false
local selectedFurniture = false
local canPlaceFurniture = false
local placedFurnitures = {}

local snapMove = false
local snapRotation = 5

local furnitureRotation = 0
local movedFurniture = false
local furnitureRotateMode = false
local rotateTick = 0

local moveTexture = dxCreateTexture("files/images/move.png")
local rotateTexture = dxCreateTexture("files/images/rotate.png")

local furnitureCategories = {"Háló", "Nappali", "Fürdő", "Konyha, étkező", "Elektronika", "Dekoráció", "Prémium"}
local mainCategories = {
	walls = "drawing",
	floors = "wood",
	doors = "doors",
	furnitures = furnitureCategories[1]
}

menuOffset.furnitures = {}

for i = 1, #furnitureCategories do
	menuOffset.furnitures[furnitureCategories[i]] = 0
end

local ppFurnitures = {}
local ppThings = {}

local doorIdModels = {
	["1"] = 1494,
	["2"] = 1492,
	["3"] = 1491,
	["4"] = 1502
}

local doorTextureNames = {
	[1494] = "CJ_SCOR_DOOR",
	[1492] = "CJ_WOODDOOR1",
	[1491] = "CJ_WOODDOOR2",
	[1502] = "CJ_WOODDOOR5"
}

local doorModelIds = {
	[1494] = "1",
	[1492] = "2",
	[1491] = "3",
	[1502] = "4"
}

local selectedItem = false
local activeHitData = false

local hoverWallData = false
local hoverElemData = false
local oldHitElement = false
local oldWindowTile = false

local soundState = true
local daytimeMode = false
local testingInterior = false

local sideGuiState = true
local sideGuiWidth = respc(56)
local sideGuiHeight = 7 * respc(56)
--local sideGuiX = screenX - sideGuiWidth
local sideGuiX = math.ceil((screenX/2 + menuHeight + navHeight) / 2 + sideGuiHeight / 2)
local sideGuiY = math.ceil((screenY - menuHeight - navHeight) / 2 - sideGuiHeight / 2)

local function calculateSideGuiSize()
	local iconNum = 0

	if testingInterior then
		iconNum = 2
	elseif editingInterior then
		iconNum = 7
	end

	if selectedFurniture or activeFurniture then
		iconNum = iconNum + 2
	end

	sideGuiHeight = iconNum * respc(56)

	if testingInterior then
		sideGuiY = math.ceil(screenY / 2 - sideGuiHeight / 2 - respc(15) / 2)
		sideGuiX = math.ceil((screenX/2 + menuHeight + navHeight) / 2 + sideGuiHeight / 2)
	else
		sideGuiY = math.ceil((screenY - menuHeight - navHeight - respc(15)) / 2 - sideGuiHeight / 2)
		sideGuiX = math.ceil((screenX/2 + menuHeight + navHeight) / 2 - sideGuiHeight / 2)
	end
end

local activeInteriorId = false
local haveOwnership = false
local standingColshape = false
local activePrompt = false
local saveInProgress = false
local saveTick = 0

local currentBalance = "0"
local cashCosts = 0
local cashCostsForDraw = "0"
local showSmallesZero = false
local lastCashCosts = 0

local tvElements = {}
local tvShaders = {}
local tvBrowsers = {}
local tvLinks = {}
local tvVolumes = {}
local selectedTV = false

local bcgMusic = false
local lastBcgMusic = 0
local musicState = true

function startBcgMusic()
	destroyElement(bcgMusic)

	local id = math.random(7)
	repeat id = math.random(7)
	until id ~= lastBcgMusic

	lastBcgMusic = id
	bcgMusic = playSound("files/sounds/background" .. id .. ".mp3")

	setSoundVolume(bcgMusic, 0.5)
end

addEventHandler("onClientSoundStopped", getRootElement(),
	function (reason)
		if reason == "finished" then
			if source == bcgMusic then
				if musicState then
					startBcgMusic()
				end
			end
		end
	end)

local infoGuiWidth = respc(600)
local infoGuiHeight = respc(500)
local infoGuiX = respc(10)
local infoGuiY = respc(10)
local infoGuiState = true
local infoLines = {}
local infoPages = {
	walls = 1,
	floors = 1,
	doors = 1,
	furnitures = 1
}

registerEvent("interiorEdit:gotPPThings", getRootElement(),
	function (datas)
		ppThings = datas
	end)

addEventHandler("onClientResourceStart", getResourceRootElement(),
	function ()
		local interiorId = getElementData(localPlayer, "currentCustomInterior") or 0

		if interiorId > 0 then
			setElementFrozen(localPlayer, true)
			triggerServerEvent("interiorEdit:loadInterior", localPlayer, interiorId, getElementData(localPlayer, "editingInterior"))
		end
	end)

addEventHandler("onClientResourceStop", getResourceRootElement(),
	function ()
		local interiorId = getElementData(localPlayer, "currentCustomInterior") or 0

		if interiorId > 0 then
			setElementFrozen(localPlayer, true)
			triggerServerEvent("requestWeather", localPlayer)
		end

		if editingInterior or testingInterior then
			exports.sm_hud:showHUD()
		end
	end)

function resetVars()
	cursorX = -1
	cursorY = -1
	activeButton = false
	activeMode = false
	activeTileX = false
	activeTileY = false
	activeTileLine = false
	activeTiles = {}
	selectedTileX = false
	selectedTileY = false
	selectedTileLine = false
	selectedTileAxis = false
	selectedItem = false
	hoverWallData = false
	activeHitData = false
	oldWindowTile = false
	oldHitElement = false
	hoverElemData = false
	placedDoor = false
	selectedFurniture = false
	testingInterior = false
	furnitureRotation = 0
	movedFurniture = false
	furnitureRotateMode = false
	saveInProgress = false
	activePrompt = false
	editingInterior = false
	haveOwnership = false
	currentBalance = "0"
	cashCosts = 0
	cashCostsForDraw = "0"
	showSmallesZero = 0
	lastCashCosts = 0
	standingColshape = false
	selectedTV = false
	ppFurnitures = {}
	ppThings = {}
	resetSkyGradient()
end

function unloadInterior()
	triggerServerEvent("interiorEdit:exitInterior", localPlayer, false)

	setMode("looking")

	removeEventHandler("onClientRender", getRootElement(), checkForUnload)

	if editingInterior then
		removeEventHandler("onClientPreRender", getRootElement(), onEditorPreRender)
		removeEventHandler("onClientRender", getRootElement(), onEditorRender)
		removeEventHandler("onClientKey", getRootElement(), onEditorKeyHandler, true, "high+999999")
		removeEventHandler("onClientCursorMove", getRootElement(), onEditorCursorMove, true, "low-999999")
		removeEventHandler("onClientClick", getRootElement(), onEditorClick)
		exports.sm_hud:showHUD()
		showCursor(false)
	else
		removeEventHandler("onClientElementDataChange", localPlayer, onClientElementDataChange)
		removeEventHandler("onClientColShapeHit", getRootElement(), onClientColShapeHit)
		removeEventHandler("onClientColShapeLeave", getRootElement(), onClientColShapeLeave)
		removeEventHandler("onClientPlayerWeaponFire", getRootElement(), onClientPlayerWeaponFire)
		removeEventHandler("onClientClick", getRootElement(), onClientClick)
		removeEventHandler("onClientKey", getRootElement(), onClientKey)
	end

	for k, v in pairs(textureShaders) do
		destroyElement(v)
		destroyElement(k)
		textureShaders[k] = nil
		texturePaths[k] = nil
	end

	for i = 1, #baseWalls do
		destroyElement(baseWalls[i])
	end

	for i = 1, #walls do
		destroyElement(walls[i])
	end

	for i = 1, #floors do
		destroyElement(floors[i])
	end

	for i = 1, #ceils do
		destroyElement(ceils[i])
	end

	for k, v in pairs(doorObjects) do
		destroyElement(v)
	end

	for k, v in pairs(doorColShape) do
		destroyElement(v)
	end

	for k, v in pairs(windowPositions) do
		destroyElement(k)
	end

	for k, v in pairs(placedFurnitures) do
		destroyElement(k)
	end

	destroyElement(currentBaseDoor[1])
	destroyElement(baseDoorColShape)
	currentBaseDoor = false
	baseDoorColShape = false

	if placedBaseDoor then
		destroyElement(placedBaseDoor[2])
	end
	placedBaseDoor = false

	textureShaders = {}
	texturePaths = {}
	textureUses = {}

	baseWalls = {}
	baseWallPositions = {}
	baseWallObjects = {}

	walls = {}
	wallPositions = {}
	wallObjects = {}

	floors = {}
	floorPositions = {}
	floorObjects = {}

	ceils = {}
	ceilPositions = {}
	ceilObjects = {}

	doorObjects = {}
	doorPositions = {}
	doorRotations = {}
	doorColShape = {}
	doorColPosition = {}
	doorStates = {}

	windowPositions = {}
	windowObjects = {}

	placedFurnitures = {}
	destroyElement(activeFurniture)
	activeFurniture = false

	destroyElement(bcgMusic)
	lastBcgMusic = 0

	resetVars()

	triggerServerEvent("requestWeather", localPlayer)
end

registerEvent("interiorEdit:onInteriorLoaded", getRootElement(),
	function (interiorId, size, editMode, savedData, dynamicData, costs, unlockedPP)
		if editMode and editingInterior then
			return
		end

		activeInteriorId = interiorId
		lastCashCosts = costs
		ppThings = unlockedPP

		local sizeX, sizeY = unpack(split(size, "x"))

		editableX = tonumber(sizeX)
		editableY = tonumber(sizeY)
		editingInterior = editMode

		RobotoL = dxCreateFont("files/fonts/RobotoL.ttf", respc(12), false, "cleartype")

		if editMode then
			if musicState then
				startBcgMusic()
			end

			showCursor(true)
			setElementPosition(localPlayer, 0, 0, 0)
			setElementInteriorAndDimension(localPlayer, 1)
			setElementFrozen(localPlayer, true)

			Roboto = dxCreateFont("files/fonts/Roboto.ttf", respc(15), false, "cleartype")
			RobotoLHeight = dxGetFontHeight(1, RobotoL)

			navDivWidth = dxGetTextWidth(" / ", 1, RobotoL)
			currentBalance = formatNumber(getElementData(localPlayer, "char.Money") or 0)


		end

		getTileSize()

		if editMode then
			cameraPivot = {
				editorX + editableX / 2 * oneTileSize,
				editorY + editableY / 2 * oneTileSize,
				editorZ - 0.1
			}

			cameraYaw = 225
			cameraPitch = 35
			cameraZoom = 40

			orbitCamera()
			reverseCamera(false)

			activeMenu = "walls"
			activeSubMenu = "drawing"
			activeMode = "looking"

			setDaytime(true)
		end

		local haveBaseDoor = false

		if savedData then
			savedData = fromString(savedData)

			-- ** Főfalak
			if savedData.baseWalls then
				for i = 1, #savedData.baseWalls do
					local dat = savedData.baseWalls[i]
					local category, name, id = unpack(split(bigPathName(dat[3]), ","))

					applyTextureToElement(baseWallObjects[dat[1]], bigTextureName(dat[2]), category, name, id, true, true)
				end
			end

			-- ** Padló
			if savedData.baseFloors then
				for i = 1, #savedData.baseFloors do
					local dat = savedData.baseFloors[i]
					local category, name, id = unpack(split(bigPathName(dat[3]), ","))
					
					applyTextureToElement(floorObjects[dat[1]], bigTextureName(dat[2]), category, name, id, true, true)
				end
			end

			-- ** Plafon
			if savedData.baseCeils then
				for i = 1, #savedData.baseCeils do
					local dat = savedData.baseCeils[i]
					local category, name, id = unpack(split(bigPathName(dat[3]), ","))
					
					applyTextureToElement(ceilObjects[dat[1]], bigTextureName(dat[2]), category, name, id, true, true)
				end
			end

			-- ** Falak
			if savedData.walls then
				for i = 1, #savedData.walls do
					local dat = savedData.walls[i]
					local pos = split(dat[1], ",")
					local wall = createWall(tonumber(pos[1]), tonumber(pos[2]), dat[2], false, dat[3])

					if dat[4] then
						for k, v in pairs(dat[4]) do
							local category, name, id = unpack(split(bigPathName(v), ","))

							applyTextureToElement(wall, bigTextureName(k), category, name, id, true, true)
						end
					end
				end
			end

			-- ** Főajtó
			if savedData.baseDoor and #savedData.baseDoor > 0 then
				haveBaseDoor = true

				savedData.baseDoor[2] = baseWallObjects[savedData.baseDoor[2]]
				savedData.baseDoor[3] = tonumber(savedData.baseDoor[3])
				savedData.baseDoor[4] = tonumber(savedData.baseDoor[4])
				savedData.baseDoor[5] = tonumber(savedData.baseDoor[5])
				savedData.baseDoor[6] = select(3, getElementRotation(savedData.baseDoor[2]))

				createBaseDoor(savedData.baseDoor, true, true)
				setCurrentBaseDoor()
			end

			-- ** Ajtók
			if savedData.doors then
				for i = 1, #savedData.doors do
					local dat = savedData.doors[i]
					local pos = split(dat[1], ",")

					createDoor(tonumber(pos[1]), tonumber(pos[2]), tonumber(dat[2]), tonumber(dat[4]), dat[3], true)
				end
			end

			-- ** Ablakok
			if savedData.windows then
				for i = 1, #savedData.windows do
					local dat = savedData.windows[i]
					local pos = split(dat[1], ",")

					createWindow(tonumber(pos[1]), tonumber(pos[2]), tonumber(dat[3]), dat[2], true)
				end
			end

			-- ** Bútorok
			if savedData.furnitures then
				for i = 1, #savedData.furnitures do
					local dat = savedData.furnitures[i]
					local model = tonumber(dat[1])

					if useableTvs[model] then
						ppFurnitures[model] = (ppFurnitures[model] or 0) + 1
					end

					if not hiFis[model] and not useableTvs[model] or editingInterior then
						local obj = createObject(model, dat[2], dat[3], dat[4], 0, 0, dat[5])

						setElementDoubleSided(obj, true)
						setObjectBreakable(obj, false)
						setElementInteriorAndDimension(obj, 1)

						placedFurnitures[obj] = true
					end
				end
			end

			-- ** Költségek
			if savedData.costs then
				cashCosts = tonumber(savedData.costs)
				cashCostsForDraw = formatNumber(cashCosts - lastCashCosts)
			end
		end

		if not haveBaseDoor then
			local obj = baseWallObjects[math.ceil(editableX / 2) .. "," .. 0 .. "," .. 1]
			local rot = select(3, getElementRotation(obj))

			createBaseDoor({false, obj, 0, 90, doorIdModels["1"], rot})
			setCurrentBaseDoor()
		end

		addEventHandler("onClientRender", getRootElement(), checkForUnload)

		if editMode then
			addEventHandler("onClientPreRender", getRootElement(), onEditorPreRender)
			addEventHandler("onClientRender", getRootElement(), onEditorRender)
			addEventHandler("onClientKey", getRootElement(), onEditorKeyHandler, true, "high+999999")
			addEventHandler("onClientCursorMove", getRootElement(), onEditorCursorMove, true, "low-999999")
			addEventHandler("onClientClick", getRootElement(), onEditorClick)

			exports.sm_hud:hideHUD()
		else
			showCeil(true)

			for k, v in pairs(doorObjects) do
				setElementCollisionsEnabled(v, true)
				setElementModel(wallObjects[k], editorModels.door)
			end

			setElementFrozen(localPlayer, false)

			addEventHandler("onClientElementDataChange", localPlayer, onClientElementDataChange)
			addEventHandler("onClientColShapeHit", getRootElement(), onClientColShapeHit)
			addEventHandler("onClientColShapeLeave", getRootElement(), onClientColShapeLeave)
			addEventHandler("onClientPlayerWeaponFire", getRootElement(), onClientPlayerWeaponFire)
			addEventHandler("onClientClick", getRootElement(), onClientClick)
			addEventHandler("onClientKey", getRootElement(), onClientKey)

			daytimeMode = false
			setDaytime(daytimeMode)

			checkOwnership()
		end

		updateDynamicData(dynamicData, true)
	end
)

function onClientElementDataChange(dataName)
	if dataName == "char.Money" then
		currentBalance = formatNumber(getElementData(localPlayer, "char.Money") or 0)
	elseif dataName == "acc.adminLevel" then
		checkOwnership()
	end
end

function checkOwnership()
	if activeInteriorId then
		haveOwnership = false

		if exports.sm_items:playerHasItemWithData(2, activeInteriorId) or getElementData(localPlayer, "adminDuty") == 1 then
			haveOwnership = true
		end
	end
end
addEventHandler("movedItemInInv", localPlayer, checkOwnership)

function onClientColShapeHit(element)
	if element == localPlayer then
		if doorColPosition[source] then
			standingColshape = doorColPosition[source]
		elseif source == baseDoorColShape then
			standingColshape = "base"
		end
	end
end

function onClientColShapeLeave(element)
	if element == localPlayer then
		if doorColPosition[source] then
			standingColshape = false
		elseif source == baseDoorColShape then
			standingColshape = false
		end
	end
end

function getTileSize()
	local obj = createObject(editorModels.floor, 0, 0, 0)
	local minX, minY, minZ, maxX, maxY, maxZ = getElementBoundingBox(obj)

	destroyElement(obj)

	oneTileSize = (math.abs(minY) + math.abs(maxY) + math.abs(minZ) + math.abs(maxZ)) / 2 - 0.01
	oneTileWidth = math.abs(minX) + math.abs(maxX)

	editorZone[1] = editorX
	editorZone[2] = editorY
	editorZone[3] = editorX + editableX * oneTileSize
	editorZone[4] = editorY + editableY * oneTileSize

	createBaseFloors()
end

function orbitCamera()
	local yaw = math.rad(cameraYaw)
	local pitch = math.rad(cameraPitch)

	if cameraReversed then
		yaw = yaw - math.pi
		pitch = pitch + math.pi
	end

	cameraPivot[4] = math.cos(yaw) * math.cos(pitch)
	cameraPivot[5] = math.sin(yaw) * math.cos(pitch)
	cameraPivot[6] = math.sin(pitch)

	cameraPivot[4] = cameraPivot[1] + cameraPivot[4] * cameraZoom
	cameraPivot[5] = cameraPivot[2] + cameraPivot[5] * cameraZoom
	cameraPivot[6] = cameraPivot[3] + cameraPivot[6] * cameraZoom
end

function reverseCamera(state)
	setActiveFurniture(false)

	cameraReversed = state

	if state then
		gridInnerZ = 3.35
		gridOuterZ = 3.65
	else
		gridInnerZ = 0.15
		gridOuterZ = -0.15
	end

	orbitCamera()
end

function createBaseFloors()
	for x = 1, editableX do
		for y = 1, editableY do
			local obj = createObject(editorModels.floor, editorX + (x - 0.5) * oneTileSize, editorY + (y - 0.5) * oneTileSize, editorZ, 0, 90, 0)
			
			if isElement(obj) then
				setElementInteriorAndDimension(obj, 1)

				floorPositions[obj] = {x, y}
				floorObjects[x .. "," .. y] = obj

				table.insert(floors, obj)
			end
		end
	end

	createBaseWalls()
end

function createBaseWalls()
	for x = 1, editableX do
		local obj = createObject(editorModels.base, editorX + (x - 0.5) * oneTileSize, editorY, editorZ + 1.75, 0, 0, 270)
		
		if isElement(obj) then
			setElementInteriorAndDimension(obj, 1)

			baseWallPositions[obj] = {x, 0, 1}
			baseWallObjects[x .. "," .. 0 .. "," .. 1] = obj

			table.insert(baseWalls, obj)
		end
	end

	for x = 1, editableX do
		local obj = createObject(editorModels.base, editorX + (x - 0.5) * oneTileSize, editorY + editableY * oneTileSize, editorZ + 1.75, 0, 0, 90)
		
		if isElement(obj) then
			setElementInteriorAndDimension(obj, 1)

			baseWallPositions[obj] = {x, editableY, 2}
			baseWallObjects[x .. "," .. editableY .. "," .. 2] = obj

			table.insert(baseWalls, obj)
		end
	end

	for y = 1, editableY do
		local obj = createObject(editorModels.base, editorX, editorY + (y - 0.5) * oneTileSize, editorZ + 1.75, 0, 0, 180)
		
		if isElement(obj) then
			setElementInteriorAndDimension(obj, 1)

			baseWallPositions[obj] = {0, y, 3}
			baseWallObjects[0 .. "," .. y .. "," .. 3] = obj

			table.insert(baseWalls, obj)
		end
	end

	for y = 1, editableY do
		local obj = createObject(editorModels.base, editorX + editableX * oneTileSize, editorY + (y - 0.5) * oneTileSize, editorZ + 1.75, 0, 0, 0)
		
		if isElement(obj) then
			setElementInteriorAndDimension(obj, 1)

			baseWallPositions[obj] = {editableX, y, 4}
			baseWallObjects[editableX .. "," .. y .. "," .. 4] = obj

			table.insert(baseWalls, obj)
		end
	end

	createBaseCeils()
end

function createBaseCeils()
	for x = 1, editableX do
		for y = 1, editableY do
			local obj = createObject(editorModels.floor, editorX + (x - 0.5) * oneTileSize, editorY + (y - 0.5) * oneTileSize, editorZ + 3.5, 180, 90, 90)
			
			if isElement(obj) then
				setElementCollisionsEnabled(obj, false)
				setElementInteriorAndDimension(obj, 2)

				ceilPositions[obj] = {x, y}
				ceilObjects[x .. "," .. y] = obj

				table.insert(ceils, obj)
			end
		end
	end
end

function getKeyStateEx()
	return getKeyState("mouse1") and getKeyState("lshift") or getKeyState("mouse3")
end

function onEditorPreRender(deltaTime)
	local x = false
	local y = false

	if not testingInterior then
		if isConsoleActive() then
			return
		end
		if getKeyState("w") then
			x = 0 - deltaTime / 1000
		elseif getKeyState("s") then
			x = 0 + deltaTime / 1000
		end

		if getKeyState("a") then
			y = 0 - deltaTime / 1000
		elseif getKeyState("d") then
			y = 0 + deltaTime / 1000
		end
	end

	if x or y then
		x = x or 0
		y = y or 0

		if getKeyState("lshift") then
			if cameraReversed then
				x = -x
			end

			cameraYaw = cameraYaw + y * cameraZoom
			cameraPitch = cameraPitch + x * -cameraZoom

			if cameraPitch >= 89.9 then
				cameraPitch = 89.9
			elseif cameraPitch <= 0 then
				cameraPitch = 0
			end

			orbitCamera()
		else
			local yaw = math.rad(cameraYaw)
			local dist = cameraZoom * 0.25

			cameraPivot[1] = cameraPivot[1] + x * dist * math.cos(yaw) - y * dist * math.sin(yaw)
			cameraPivot[2] = cameraPivot[2] + x * dist * math.sin(yaw) + y * dist * math.cos(yaw)

			if cameraPivot[1] < editorZone[1] then
				cameraPivot[1] = editorZone[1]
			elseif cameraPivot[1] > editorZone[3] then
				cameraPivot[1] = editorZone[3]
			end

			if cameraPivot[2] < editorZone[2] then
				cameraPivot[2] = editorZone[2]
			elseif cameraPivot[2] > editorZone[4] then
				cameraPivot[2] = editorZone[4]
			end

			orbitCamera()
		end
	end
end

function getCursorPositionEx()
	if cursorAbsPos then
		return unpack(cursorAbsPos)
	elseif isCursorShowing() then
		local cx, cy = getCursorPosition()
		return cx * screenX, cy * screenY
	end

	return -1, -1
end

function setDaytime(state)
	if state ~= nil then
		daytimeMode = state
	else
		daytimeMode = not daytimeMode
	end

	resetSkyGradient()
	keepDaytime()
end

function keepDaytime()
	if daytimeMode then
		setWeather(4)
		setSkyGradient(93.75, 108.75, 113.25, 93.75, 108.75, 113.25)
		setTime(16, 0)
	else
		setSkyGradient(62.5, 72.5, 75.5, 62.5, 72.5, 75.5)
		setTime(0, 0)
		setWeather(22)
	end
end

local movieListOffset = 0
local movieList = {
	{"Babysitting - A felvigyázó", "05r8tnR7WSU"},
	{"Csak egy átlagos suli", "tmI7jGVIp90"},
	{"Üvegtigris 3", "oi9oN-PLYds"},
	{"Kegyenc Fegyenc", "v9hGdegdOhw"},
	{"Az ördög jobb és bal keze", "DprNxTB6Apc"},
	{"Brazilok", "V07GQMKwh14"},
	{"Haláli Iramban", "28O7WFq_ids"},
	{"Halálos sebesség", "OstcimxqfXg"},
	{"Pókerpárbaj", "_H10Cn1cawI"},
	{"Sétáló agyhalottak", "CHGywcA--Wc"},
	{"Óvóbácsik", "gPNIWpD6me4"},
	{"Csonthülye", "6-4Rr_YI9F8"},
	{"Nincs kettő négy nélkül", "4Ed96Zl2qmg"},
	{"Bűnvadászok", "6sdzCv0MAas"},
	{"Pofa Be", "LBx8FvSkV5o"},
	{"Csapdában", "vDsm7NwAw2o"},
	--{"Nagyfiúk 2", "uE3H2FYX4wg"},
	--{"Lopott idő", "yi-JAlcwatA"},
	{"Vadászat", "LXh070FanVY"},
	{"Az éhezők viadala", "Ac7HYmo9Pd0"},
}

local tableAccents = {}
tableAccents["à"] = "a"
tableAccents["á"] = "a"
tableAccents["â"] = "a"
tableAccents["ã"] = "a"
tableAccents["ä"] = "a"
tableAccents["ç"] = "c"
tableAccents["è"] = "e"
tableAccents["é"] = "e"
tableAccents["ê"] = "e"
tableAccents["ë"] = "e"
tableAccents["ì"] = "i"
tableAccents["í"] = "i"
tableAccents["î"] = "i"
tableAccents["ï"] = "i"
tableAccents["ñ"] = "n"
tableAccents["ò"] = "o"
tableAccents["ó"] = "o"
tableAccents["ô"] = "o"
tableAccents["õ"] = "o"
tableAccents["ö"] = "o"
tableAccents["ù"] = "u"
tableAccents["ú"] = "u"
tableAccents["û"] = "u"
tableAccents["ü"] = "u"
tableAccents["ý"] = "y"
tableAccents["ÿ"] = "y"
tableAccents["À"] = "A"
tableAccents["Á"] = "A"
tableAccents["Â"] = "A"
tableAccents["Ã"] = "A"
tableAccents["Ä"] = "A"
tableAccents["Ç"] = "C"
tableAccents["È"] = "E"
tableAccents["É"] = "E"
tableAccents["Ê"] = "E"
tableAccents["Ë"] = "E"
tableAccents["Ì"] = "I"
tableAccents["Í"] = "I"
tableAccents["Î"] = "I"
tableAccents["Ï"] = "I"
tableAccents["Ñ"] = "N"
tableAccents["Ò"] = "O"
tableAccents["Ó"] = "O"
tableAccents["Ô"] = "O"
tableAccents["Õ"] = "O"
tableAccents["Ö"] = "O"
tableAccents["Ù"] = "U"
tableAccents["Ú"] = "U"
tableAccents["Û"] = "U"
tableAccents["Ü"] = "U"
tableAccents["Ý"] = "Y"

function stripAccents(text)
	local normalized = ""

	for character in string.gfind(text, "([%z\1-\127\194-\244][\128-\191]*)") do
		if tableAccents[character] then
			normalized = normalized .. tableAccents[character]
		else
			normalized = normalized .. character
		end
	end

	return normalized
end

function youtubeLinkCompare(a, b)
	return stripAccents(a[1]) < stripAccents(b[1])
end

table.sort(movieList, youtubeLinkCompare)

function checkForUnload()
	buttonsC = {}

	keepDaytime()

	if getElementDimension(localPlayer) ~= activeInteriorId then
		unloadInterior()
	end

	if not editingInterior then
		local cx, cy = getCursorPositionEx()

		activeButton = false

		if standingColshape then
			local oneSize = respc(48)
			local marginSize = respc(12)

			if standingColshape == "base" then
				local x = math.ceil(screenX / 2 - oneSize)
				local y = math.ceil(screenY - oneSize * 2 - marginSize * 4)
				
				dxDrawRectangle(x - marginSize, y - marginSize, oneSize + marginSize * 2, oneSize + marginSize * 2, tocolor(0, 0, 0, 125))
				
				if cx >= x - marginSize and cx <= x + oneSize + marginSize * 2 and cy >= y - marginSize and cy <= y + oneSize + marginSize * 2 then
					activeButton = "switchLight"
					dxDrawImage(x, y, oneSize, oneSize, "files/images/" .. (daytimeMode and "lighton" or "lightoff") .. ".png", 0, 0, 0, tocolor(61, 122, 188))
				else
					dxDrawImage(x, y, oneSize, oneSize, "files/images/" .. (daytimeMode and "lighton" or "lightoff") .. ".png")
				end
			elseif haveOwnership then
				local x = math.ceil(screenX / 2 - oneSize)
				local y = math.ceil(screenY - oneSize * 2 - marginSize * 4)
				
				dxDrawRectangle(x - marginSize, y - marginSize, oneSize + marginSize * 2, oneSize + marginSize * 2, tocolor(0, 0, 0, 125))
				
				if doorStates[standingColshape] ~= "damaged" then
					if cx >= x - marginSize and cx <= x + oneSize + marginSize * 2 and cy >= y - marginSize and cy <= y + oneSize + marginSize * 2 then
						activeButton = "doorLock"
						dxDrawImage(x, y, oneSize, oneSize, "files/images/" .. (doorStates[standingColshape] and "unlock" or "lock") .. ".png", 0, 0, 0, tocolor(61, 122, 188))
					else
						dxDrawImage(x, y, oneSize, oneSize, "files/images/" .. (doorStates[standingColshape] and "lock" or "unlock") .. ".png")
					end
				else
					dxDrawImage(x, y, oneSize, oneSize, "files/images/brokenlock.png", 0, 0, 0, tocolor(215, 89, 89))
				end
			end
		end

		if selectedTV then
			if selectedTVMode == "yt" then
				local sx, sy = screenX / 1.5, screenY / 1.5
				local x, y = screenX / 6, screenY / 6

				if isElement(tvBrowser) then
					local url = getBrowserURL(guiGetBrowser(tvBrowser))

					if url and utf8.find(url, "watch") then
						if cx >= x and cy >= y - respc(50) and cx <= x + sx and cy <= y then
							activeButton = "playMovie:" .. url
						--	dxDrawRectangle(x, y - respc(50), sx, respc(50), tocolor(61, 122, 188))
						--else
						--	dxDrawRectangle(x, y - respc(50), sx, respc(50), tocolor(61, 122, 188, 175))
						end

						--dxDrawText("Lejátszás", x, y - respc(50), x + sx, y, tocolor(200, 200, 200, 200), 1, RobotoL, "center", "center")
						drawButton("playMovie:" .. url, "Lejátszás", x, y - respc(50), sx, respc(50), {61, 122, 188}, false, RobotoL)
					end
				end

				if cx >= x and cy >= y + sy and cx <= x + sx and cy <= y + sy + respc(50) then
					activeButton = "exitSelectedTV"
					--dxDrawRectangle(x, y + sy, sx, respc(50), tocolor(215, 89, 89))
				else
					--dxDrawRectangle(x, y + sy, sx, respc(50), tocolor(215, 89, 89, 175))
				end

				drawButton("exitSelectedTV", "Bezárás", x, y + sy, sx, respc(50), {215, 89, 89}, false, RobotoL)

				--dxDrawText("Bezárás", x, y + sy, x + sx, y + sy + respc(50), tocolor(200, 200, 200, 200), 1, RobotoL, "center", "center")
			elseif selectedTVMode == "movielist" then
				local oneSize = respc(40)
				local sx, sy = respc(365), oneSize * 11

				local x = screenX / 2 - sx / 2
				local y = screenY / 2 - sy / 2
				dxDrawRectangle(x, y-respc(4), sx, sy+respc(8), tocolor(25, 25, 25))
				for i = 1, 10 do
					local rowY = y + oneSize * (i - 1)
					if (i + movieListOffset) % 2 == 0 then
						dxDrawRectangle(x+respc(4), rowY, sx-respc(8), oneSize, tocolor(35, 35, 35))
					else
						dxDrawRectangle(x+respc(4), rowY, sx-respc(8), oneSize, tocolor(45, 45, 45))
					end
					
					local movie = movieList[i + movieListOffset]

					if movie then
						dxDrawText(movie[1], x + respc(8), rowY, 0, rowY + oneSize, tocolor(200, 200, 200, 200), 1, RobotoL, "left", "center", false, false, false, true)

						if tvLinks[selectedTV] == movie[2] then
							dxDrawText("AKTÍV", x + sx - respc(96), rowY, x + sx - respc(8), rowY + oneSize, tocolor(61, 122, 188), 1, RobotoL, "center", "center")
						else
							if cx >= x + sx - respc(96) and cx <= x + sx - respc(8) and cy >= rowY + respc(8) and cy <= rowY + oneSize - respc(8) then
								activeButton = "playMovie:" .. movie[2]
							--	exports.sm_hud:dxDrawRoundedRectangle(x + sx - respc(96), rowY + respc(8), respc(88), oneSize - respc(16), tocolor(61, 122, 188))
							--else
							--	exports.sm_hud:dxDrawRoundedRectangle(x + sx - respc(96), rowY + respc(8), respc(88), oneSize - respc(16), tocolor(61, 122, 188, 175))
							end
							drawButton("playMovie:" .. movie[2], "Lejátszás", x + sx - respc(96), rowY + respc(8), respc(88), oneSize - respc(16), {61, 122, 188}, false, RobotoL)

							--dxDrawText("Lejátszás", x + sx - respc(96), rowY, x + sx - respc(8), rowY + oneSize, tocolor(200, 200, 200, 200), 1, RobotoL, "center", "center")
						end
					end
				end

				y = y + oneSize * 10

				if cx >= x and cy >= y and cx <= x + sx and cy <= y + oneSize then
					activeButton = "exitSelectedTV"
				--	dxDrawRectangle(x+respc(4), y, sx-respc(8), oneSize, tocolor(215, 89, 89, 200))
				--else
				--	dxDrawRectangle(x+respc(4), y, sx-respc(8), oneSize, tocolor(215, 89, 89, 150))
				end
				drawButton("exitSelectedTV", "Bezárás", x + respc(4), y, sx - respc(8), oneSize, {215, 89, 89}, false, RobotoL)
				--dxDrawText("Bezárás", x, y, x + sx, y + oneSize, tocolor(200, 200, 200, 200), 1, RobotoL, "center", "center")
			else
				local oneSize = respc(40)
				local sx, sy = respc(365), oneSize * 4 + respc(5) * 3

				if tvBrowsers[selectedTV] then
					sy = oneSize * 5 + respc(5) * 4
				end

				local x = screenX / 2 - sx / 2
				local y = screenY / 2 - sy / 2
				dxDrawRectangle(x, y-respc(5), sx, sy+respc(10), tocolor(25, 25, 25))
				if cx >= x and cy >= y and cx <= x + sx and cy <= y + oneSize then
					activeButton = "openYouTube"
					--dxDrawRectangle(x+respc(5), y, sx-respc(10), oneSize, tocolor(61, 122, 188, 200))
				--else
					--dxDrawRectangle(x+respc(5), y, sx-respc(10), oneSize, tocolor(61, 122, 188, 150))
				end

				drawButton("openYouTube", "YouTube", x+respc(5), y, sx-respc(10), oneSize, {61, 122, 188}, false, RobotoL)
				--dxDrawText("YouTube", x, y, x + sx, y + oneSize, tocolor(200, 200, 200, 200), 1, RobotoL, "center", "center")

				y = y + oneSize + respc(5)

				if cx >= x and cy >= y and cx <= x + sx and cy <= y + oneSize then
					activeButton = "openMovieList"
					--dxDrawRectangle(x+respc(5), y, sx-respc(10), oneSize, tocolor(61, 122, 188, 200))
				--else
				--	dxDrawRectangle(x+respc(5), y, sx-respc(10), oneSize, tocolor(61, 122, 188, 150))
				end

				drawButton("openMovieList", "Filmlista", x+respc(5), y, sx-respc(10), oneSize, {61, 122, 188}, false, RobotoL)
				--dxDrawText("Filmlista", x, y, x + sx, y + oneSize, tocolor(200, 200, 200, 200), 1, RobotoL, "center", "center")

				y = y + oneSize + respc(5)

				dxDrawRectangle(x, y, sx, oneSize, tocolor(25, 25, 25))
				dxDrawText("Hangerő", x + respc(8), y, 0, y + oneSize, tocolor(200, 200, 200, 200), 1, RobotoL, "left", "center")

				local sliderWidth = sx - respc(100)
				local sliderHeight = respc(10)

				local sliderX = x + sx - sliderWidth - respc(8)
				local sliderY = y + (oneSize - respc(10)) / 2

				local sliderLevel = reMap((tvVolumes[selectedTV] or 1), 0, 1, 0, sliderWidth)

				dxDrawRectangle(sliderX, sliderY, sliderWidth, sliderHeight, tocolor(124, 127, 132, 180))
				dxDrawRectangle(sliderX, sliderY, sliderLevel, sliderHeight, tocolor(61, 122, 188))

				if getKeyState("mouse1") and cx >= sliderX and cx <= sliderX + sliderWidth and cy >= sliderY and cy <= sliderY + sliderHeight then
					local value = reMap(sliderX + (cx - sliderX), sliderX, sliderX + sliderWidth, 0, 1)

					tvVolumes[selectedTV] = math.ceil(value * 100) / 100
					tvVolumeSync = {getTickCount(), tvVolumes[selectedTV]}
				else
					if tvVolumeSync and getTickCount() - tvVolumeSync[1] >= 250 then
						setElementData(selectedTV, "tv.volume", tvVolumeSync[2])
						tvVolumeSync = false
					end
				end

				y = y + oneSize + respc(5)

				if tvBrowsers[selectedTV] then
					if cx >= x and cy >= y and cx <= x + sx and cy <= y + oneSize then
						activeButton = "stopMovie"
					--	dxDrawRectangle(x+respc(5), y, sx-respc(10), oneSize, tocolor(215, 89, 89))
					--else
					--	dxDrawRectangle(x+respc(5), y, sx-respc(10), oneSize, tocolor(215, 89, 89, 175))
					end
					drawButton("stopMovie", "TV kikapcsolása", x+respc(5), y, sx-respc(10), oneSize, {215, 89, 89}, false, RobotoL)
					--dxDrawText("TV kikapcsolása", x, y, x + sx, y + oneSize, tocolor(200, 200, 200, 200), 1, RobotoL, "center", "center")

					y = y + oneSize + respc(5)
				end

				if cx >= x and cy >= y and cx <= x + sx and cy <= y + oneSize then
					activeButton = "exitSelectedTV"
				--	dxDrawRectangle(x+respc(5), y, sx-respc(10), oneSize, tocolor(215, 89, 89))
				--else
					--dxDrawRectangle(x+respc(5), y, sx-respc(10), oneSize, tocolor(215, 89, 89, 175))
				end

				drawButton("exitSelectedTV", "Bezárás", x+respc(5), y, sx-respc(10), oneSize, {215, 89, 89}, false, RobotoL)
				--dxDrawText("Bezárás", x, y, x + sx, y + oneSize, tocolor(200, 200, 200, 200), 1, RobotoL, "center", "center")

				
			end

			local px, py = getElementPosition(localPlayer)
			local tx, ty = getElementPosition(selectedTV)

			if getDistanceBetweenPoints2D(px, py, tx, ty) >= 10 then
				setElementData(selectedTV, "tvInUse", false)
				selectedTV = false

				destroyElement(tvBrowser)
				tvBrowser = false

				destroyElement(tvBrowserBg)
				tvBrowserBg = nil
			end
		end

		local cx, cy = getCursorPosition()

		activeButtonC = false

		if cx then
			cx = cx * screenX
			cy = cy * screenY

			for k, v in pairs(buttonsC) do
				if cx >= v[1] and cx <= v[1] + v[3] and cy >= v[2] and cy <= v[2] + v[4] then
					activeButtonC = k
					break
				end
			end
		end

		local camx, camy, camz = getCameraMatrix()

		for i = 1, #tvElements do
			local obj = tvElements[i]
			
			if isElement(obj) and isElement(tvBrowsers[obj]) then
				local tx, ty, tz = getElementPosition(obj)
				local volume = (tvVolumes[obj] or 1) - getDistanceBetweenPoints3D(camx, camy, camz, tx, ty, tz) / 30
				
				if volume < 0 then
					volume = 0
				end

				setBrowserVolume(tvBrowsers[obj], volume)
			end
		end
	end
end

addEventHandler("onClientElementDataChange", getRootElement(),
	function (dataName)
		if dataName == "tv.volume" then
			tvVolumes[source] = getElementData(source, "tv.volume") or 1
		end
	end)

local clickTick = 0

function onClientClick(button, state, absX, absY, worldX, worldY, worldZ, clickedElement)
	if state == "down" then
		if button == "left" and activeButton then
			if getTickCount() - clickTick > 1000 then
				clickTick = getTickCount()

				if activeButton == "switchLight" then
					daytimeMode = not daytimeMode

					setDaytime(daytimeMode)
					saveDynamicData()

					playSound("files/sounds/poweronoff.mp3")
				elseif activeButton == "doorLock" then
					checkOwnership()

					if standingColshape and haveOwnership then
						if doorStates[standingColshape] ~= "inservice" and doorStates[standingColshape] ~= "damaged" then
							doorStates[standingColshape] = not doorStates[standingColshape]

							local rot = select(3, getElementRotation(wallObjects[standingColshape]))

							setElementRotation(doorObjects[standingColshape], 0, 0, doorRotations[doorObjects[standingColshape]] + rot)

							if doorStates[standingColshape] then
								setElementCollisionsEnabled(doorObjects[standingColshape], false)
								setElementModel(wallObjects[standingColshape], editorModels.door2)
							else
								setElementCollisionsEnabled(doorObjects[standingColshape], true)
								setElementModel(wallObjects[standingColshape], editorModels.door)
							end

							playSound(":sm_interiors/files/sounds/openclose.mp3")
							saveDynamicData()
						end
					end
				elseif activeButton == "exitSelectedTV" then
					if selectedTV then
						setElementData(selectedTV, "tvInUse", false)
					end

					selectedTV = false

					destroyElement(tvBrowser)
					tvBrowser = nil

					destroyElement(tvBrowserBg)
					tvBrowserBg = nil
				elseif activeButton == "openYouTube" then
					if selectedTV then
						destroyElement(tvBrowser)

						selectedTVMode = "yt"

						tvBrowserBg = guiCreateStaticImage(screenX / 6, screenY / 6, screenX / 1.5, screenY / 1.5, "files/ytbg.png", false)
						tvBrowser = guiCreateBrowser(0, 0, screenX / 1.5, screenY / 1.5, false, false, false, tvBrowserBg)

						setElementData(tvBrowser, "URL", "https://www.youtube.com/")
						setElementData(tvBrowser, "isLocalBrowser", true)
					end
				elseif activeButton == "openMovieList" then
					if selectedTV then
						selectedTVMode = "movielist"
					end
				elseif utf8.find(activeButton, "playMovie") then
					if selectedTV then
						triggerServerEvent("interiorEdit:playTvMovie", selectedTV, activeButton:gsub("playMovie:", ""), activeInteriorId, selectedTVMode == "movielist")
						playSound("files/sounds/poweronoff.mp3")

						setElementData(selectedTV, "tvInUse", false)
						selectedTV = false

						destroyElement(tvBrowser)
						tvBrowser = nil

						destroyElement(tvBrowserBg)
						tvBrowserBg = nil
					end
				elseif activeButton == "stopMovie" then
					if selectedTV then
						triggerServerEvent("interiorEdit:stopTvMovie", selectedTV, activeInteriorId)
						playSound("files/sounds/poweronoff.mp3")

						setElementData(selectedTV, "tvInUse", false)
						selectedTV = false

						destroyElement(tvBrowser)
						tvBrowser = nil

						destroyElement(tvBrowserBg)
						tvBrowserBg = nil
					end
				end
			else
				exports.sm_hud:showInfobox("e", "Nem tudod ilyen gyorsan!")
			end
		elseif clickedElement then
			if isUseableTV(clickedElement) then
				if not selectedTV then
					local px, py = getElementPosition(localPlayer)
					local tx, ty = getElementPosition(clickedElement)

					if getDistanceBetweenPoints2D(px, py, tx, ty) < 6 then
						if getElementData(clickedElement, "tvInUse") then
							exports.sm_hud:showInfobox("e", "Jelenleg valaki más kezeli a TV-t!")
						else
							selectedTV = clickedElement
							selectedTVMode = false
							setElementData(clickedElement, "tvInUse", true)
						end
					end
				end
			end
		end
	end
end

function onClientKey(key, state)
	if selectedTV then
		if key ~= "escape" and state then
			cancelEvent()
		end

		if selectedTVMode == "movielist" then
			if key == "mouse_wheel_up" then
				movieListOffset = movieListOffset - 1

				if movieListOffset < 0 then
					movieListOffset = 0
				else
					playSound("files/sounds/scrollmenu.mp3")
				end
			elseif key == "mouse_wheel_down" then
				movieListOffset = movieListOffset + 1

				if movieListOffset > #movieList - 10 then
					movieListOffset = #movieList - 10
				else
					playSound("files/sounds/scrollmenu.mp3")
				end
			end
		end
	end
end

addEventHandler("onClientBrowserCreated", getResourceRootElement(),
	function ()
		if getElementData(source, "isLocalBrowser") then
			setBrowserProperty(source, "mobile", "1")
		end

		loadBrowserURL(source, getElementData(source, "URL"))
	end)

addEventHandler("onClientPlayerQuit", localPlayer,
	function ()
		if selectedTV then
			setElementData(selectedTV, "tvInUse", false)
		end
	end)

addEventHandler("onClientPlayerWasted", localPlayer,
	function ()
		if selectedTV then
			setElementData(selectedTV, "tvInUse", false)
		end
	end)

function isUseableTV(element)
	return useableTvs[getElementModel(element)] and getElementData(element, "tvFurniture")
end

addEventHandler("onClientElementStreamIn", getResourceRootElement(),
	function ()
		if isUseableTV(source) and not editingInterior then
			table.insert(tvElements, source)
			triggerServerEvent("interiorEdit:requestTvMovie", source)
		end
	end)

function tvStreamOut()
	if isUseableTV(source) then
		for i = 1, #tvElements do
			if tvElements[i] == source then
				table.remove(tvElements, i)
				break
			end
		end

		destroyElement(tvBrowsers[source])
		destroyElement(tvShaders[source])

		tvBrowsers[source] = nil
		tvShaders[source] = nil
		tvLinks[source] = nil
	end
end
addEventHandler("onClientElementDestroy", getResourceRootElement(), tvStreamOut)
addEventHandler("onClientElementStreamOut", getResourceRootElement(), tvStreamOut)

registerEvent("interiorEdit:playTvMovie", getRootElement(),
	function (url, startTime)
		if isElement(source) then
			if url then
				if not isElement(tvBrowsers[source]) or not isElement(tvShaders[source]) then
					destroyElement(tvShaders[source])
					destroyElement(tvBrowsers[source])

					tvBrowsers[source] = createBrowser(512, 256, false, true)
					tvShaders[source] = dxCreateShader("files/tvtexture.fx", 1, 0, true, "object")

					engineApplyShaderToWorldTexture(tvShaders[source], "tv", source)
					dxSetShaderValue(tvShaders[source], "browserTexture", tvBrowsers[source])
				end

				if startTime and tonumber(startTime) then
					startTime = "&start=" .. startTime
				else
					startTime = ""
				end

				local link = "https://www.youtube.com/embed/" .. url .. "?autoplay=1&controls=0&showinfo=0&autohide=1" .. startTime

				tvLinks[source] = url

				setElementData(tvBrowsers[source], "URL", link)
				loadBrowserURL(tvBrowsers[source], link)
			else
				destroyElement(tvBrowsers[source])
				destroyElement(tvShaders[source])

				tvBrowsers[source] = nil
				tvShaders[source] = nil
				tvLinks[source] = nil
			end
		end
	end)

function onEditorRender()
	cursorX, cursorY = getCursorPositionEx()
	oldActiveButton = activeButton
	activeButton = false

	if testingInterior then
		local playerZ = select(3, getElementPosition(localPlayer))

		if playerZ < editorZ - 1 then
			setTest()
		end

		drawSideGUI()
	elseif editingInterior then
		setCameraMatrix(cameraPivot[4], cameraPivot[5], cameraPivot[6], cameraPivot[1], cameraPivot[2], cameraPivot[3])

		local worldX, worldY, worldZ = getWorldFromScreenPosition(cursorX, cursorY, 1000)
		local hit, hitX, hitY, hitZ, hitElement = processLineOfSight(cameraPivot[4], cameraPivot[5], cameraPivot[6], worldX, worldY, worldZ, false, false, false, true, false)

		if not hit then
			hitX, hitY, hitZ = -1000, -1000, -1000
		end

		if selectedFurniture then
			if movedFurniture then
				if movedFurniture[8] == true then
					local z = editorZ + getElementDistanceFromCentreOfMassToBaseOfModel(selectedFurniture) + oneTileWidth / 2

					if not snapMove then
						z = movedFurniture[7]
					else
						z = z + math.ceil((movedFurniture[7] - z) * snapMove) / snapMove
					end

					setElementPosition(selectedFurniture, movedFurniture[5], movedFurniture[6], z)
				end
			end

			local model = getElementModel(selectedFurniture)
			local x, y, z = getElementPosition(selectedFurniture)
			local rz = select(3, getElementRotation(selectedFurniture))
			local minX, minY, maxX, maxY, minZ, size = 0, 0, 0, 0, 0, 0

			if boundingBox[model] then
				local box = boundingBox[model]
				local angle = math.rad(rz)
				local rotatedX, rotatedY = rotateAround(angle, 0, 0, box[7], box[8])

				x = x + rotatedX
				y = y + rotatedY

				local rotatedXX, rotatedXY = rotateAround(angle, x, y, x + box[4] - box[7], y + box[5] - box[8])
				local rotatedYX, rotatedYY = rotateAround(angle, x, y, x + box[1] - box[7], y + box[2] - box[8])
				
				size = math.max(box[1] - box[4], box[2] - box[5]) * 0.75
				minX = math.min(rotatedXX, rotatedYX)
				minY = math.min(rotatedXY, rotatedYY)
				maxX = math.max(rotatedYX, rotatedXX)
				maxY = math.max(rotatedYY, rotatedXY)
				minZ = box[3]
			end

			local sx, sy = getScreenFromWorldPosition(x, y, z + minZ + 0.25)

			if sx and sy then
				local iconNum = 5

				if furnitureRotateMode then
					iconNum = 3
				end

				local iconSize = respc(32)
				local sx = sx - (iconSize * iconNum) / 2
				local sy = sy - iconSize

				-- ** Háttér
				dxDrawRectangle(sx, sy, iconSize * iconNum, iconSize, tocolor(0, 0, 0, 150))

				-- ** Forgatás mód
				if cursorX >= sx and cursorX <= sx + iconSize and cursorY >= sy and cursorY <= sy + iconSize then
					activeButton = "rotateMode:on"
					dxDrawImage(sx, sy, iconSize, iconSize, "files/images/rotateicon.png", 0, 0, 0, tocolor(50, 179, 239))
				elseif furnitureRotateMode then
					dxDrawImage(sx, sy, iconSize, iconSize, "files/images/rotateicon.png", 0, 0, 0, tocolor(61, 122, 188))
				else
					dxDrawImage(sx, sy, iconSize, iconSize, "files/images/rotateicon.png")
				end

				-- ** Mozgatás mód
				if cursorX >= sx + iconSize and cursorX <= sx + iconSize * 2 and cursorY >= sy and cursorY <= sy + iconSize then
					activeButton = "rotateMode:off"
					dxDrawImage(sx + iconSize, sy, iconSize, iconSize, "files/images/moveicon.png", 0, 0, 0, tocolor(50, 179, 239))
				elseif not furnitureRotateMode then
					dxDrawImage(sx + iconSize, sy, iconSize, iconSize, "files/images/moveicon.png", 0, 0, 0, tocolor(61, 122, 188))
				else
					dxDrawImage(sx + iconSize, sy, iconSize, iconSize, "files/images/moveicon.png")
				end

				if not furnitureRotateMode then
					-- ** Mozgatás a padlóra
					if cursorX >= sx + iconSize * 2 and cursorX <= sx + iconSize * 3 and cursorY >= sy and cursorY <= sy + iconSize then
						activeButton = "placeOnFloor"
						dxDrawImage(sx + iconSize * 2, sy, iconSize, iconSize, "files/images/onfloor.png", 0, 0, 0, tocolor(61, 122, 188))
					else
						dxDrawImage(sx + iconSize * 2, sy, iconSize, iconSize, "files/images/onfloor.png")
					end

					-- ** Mozgatás fel/le
					if (cursorX >= sx + iconSize * 3 and cursorX <= sx + iconSize * 4 and cursorY >= sy and cursorY <= sy + iconSize) or movedFurniture and movedFurniture[8] == true then
						dxDrawImage(sx + iconSize * 3, sy, iconSize, iconSize, "files/images/updown.png", 0, 0, 0, tocolor(61, 122, 188))

						if not getKeyStateEx() then
							activeButton = "upDownFurniture"
							moveFurniture(cursorX, cursorY, sx + iconSize * 3, sy, true)
						end
					else
						dxDrawImage(sx + iconSize * 3, sy, iconSize, iconSize, "files/images/updown.png")
					end
				end

				-- ** Törlés
				if cursorX >= sx + iconSize * (iconNum - 1) and cursorX <= sx + iconSize * iconNum and cursorY >= sy and cursorY <= sy + iconSize then
					activeButton = "deleteFurniture"
					dxDrawImage(sx + iconSize * (iconNum - 1), sy, iconSize, iconSize, "files/images/delete.png", 0, 0, 0, tocolor(215, 89, 89))
				else
					dxDrawImage(sx + iconSize * (iconNum - 1), sy, iconSize, iconSize, "files/images/delete.png")
				end
			elseif movedFurniture and movedFurniture[8] == true then
				if not getKeyStateEx() then
					moveFurniture(cursorX, cursorY, false, false, true)
				end
			end

			z = editorZ + gridInnerZ

			if furnitureRotateMode then
				if not movedFurniture and not activeButton and (hitX >= x - size and hitY >= y - size and hitX <= x + size and hitY <= y + size) or movedFurniture then
					dxDrawMaterialLine3D(x - size, y, z, x + size, y, z, rotateTexture, size * 2, tocolor(61, 122, 188), x, y, z + 10)
					
					if not getKeyStateEx() then
						activeButton = "moveFurniture"
						moveFurniture(hitX, hitY, 0, 0)
					end
				else
					dxDrawMaterialLine3D(x - size, y, z, x + size, y, z, rotateTexture, size * 2, tocolor(255, 255, 255), x, y, z + 10)
				end

				if sx and sy then
					local iconSize = respc(32)
					local text = math.floor(rz * 10) / 10 .. "°"
					local length = dxGetTextWidth(text, 1, Roboto) + respc(6)

					dxDrawRectangle(sx - length / 2, sy - iconSize * 2 - respc(6), length, iconSize + respc(4), tocolor(0, 0, 0, 150))
					dxDrawText(text, sx, 0, sx, sy - iconSize - respc(6), tocolor(255, 255, 255), 1, Roboto, "center", "bottom")
				end
			else
				local size = 1.5

				-- Balra
				if not movedFurniture and not activeButton and (hitX >= minX - size and hitY >= y - size / 2 and hitX <= minX and hitY <= y + size / 2) or movedFurniture and movedFurniture[3] == -1 then
					dxDrawMaterialLine3D(minX - size, y, z, minX, y, z, moveTexture, size, tocolor(61, 122, 188), minX - 0.5, y, z + 10)
					
					if not getKeyStateEx() then
						activeButton = "moveFurniture"
						moveFurniture(hitX, hitY, -1, 0)
					end
				else
					dxDrawMaterialLine3D(minX - size, y, z, minX, y, z, moveTexture, size, tocolor(255, 255, 255), minX - 0.5, y, z + 10)
				end

				-- Jobbra
				if not movedFurniture and not activeButton and (hitX >= maxX and hitY >= y - size / 2 and hitX <= maxX + size and hitY <= y + size / 2) or movedFurniture and movedFurniture[3] == 1 then
					dxDrawMaterialLine3D(maxX + size, y, z, maxX, y, z, moveTexture, size, tocolor(61, 122, 188), maxX + 0.5, y, z + 10)
						
					if not getKeyStateEx() then
						activeButton = "moveFurniture"
						moveFurniture(hitX, hitY, 1, 0)
					end
				else
					dxDrawMaterialLine3D(maxX + size, y, z, maxX, y, z, moveTexture, size, tocolor(255, 255, 255), maxX + 0.5, y, z + 10)
				end

				-- Fel
				if not movedFurniture and not activeButton and (hitX >= x - size / 2 and hitY >= minY - size and hitX <= x + size / 2 and hitY <= minY) or movedFurniture and movedFurniture[4] == -1 then
					dxDrawMaterialLine3D(x, minY - size, z, x, minY, z, moveTexture, size, tocolor(61, 122, 188), x, minY - 0.5, z + 10)
					
					if not getKeyStateEx() then
						activeButton = "moveFurniture"
						moveFurniture(hitX, hitY, 0, -1)
					end
				else
					dxDrawMaterialLine3D(x, minY - size, z, x, minY, z, moveTexture, size, tocolor(255, 255, 255), x, minY - 0.5, z + 10)
				end

				-- Le
				if not movedFurniture and not activeButton and (hitX >= x - size / 2 and hitY >= maxY and hitX <= x + size / 2 and hitY <= maxY + size) or movedFurniture and movedFurniture[4] == 1 then
					dxDrawMaterialLine3D(x, maxY + size, z, x, maxY, z, moveTexture, size, tocolor(61, 122, 188), x, maxY + 0.5, z + 10)
					
					if not getKeyStateEx() then
						activeButton = "moveFurniture"
						moveFurniture(hitX, hitY, 0, 1)
					end
				else
					dxDrawMaterialLine3D(x, maxY + size, z, x, maxY, z, moveTexture, size, tocolor(255, 255, 255), x, maxY + 0.5, z + 10)
				end
			end
		end

		if activeMode == "placeFurniture" then
			if hitElement and floorPositions[hitElement] then
				local model = getElementModel(activeFurniture)
				local x, y = hitX, hitY
				local rotatedX, rotatedY = 0, 0

				if boundingBox[model] then
					rotatedX, rotatedY = rotateAround(math.rad(furnitureRotation), 0, 0, boundingBox[model][7], boundingBox[model][8])
				end

				if not snapMove then
					x = hitX - rotatedX
					y = hitY - rotatedY
				else
					x = math.floor((hitX - rotatedX) * snapMove) / snapMove
					y = math.floor((hitY - rotatedY) * snapMove) / snapMove
				end

				setElementPosition(activeFurniture, x, y, editorZ + getElementDistanceFromCentreOfMassToBaseOfModel(activeFurniture) + oneTileWidth / 2)
				canPlaceFurniture = true
			else
				setElementPosition(activeFurniture, 0, 0, 0)
				canPlaceFurniture = false
			end
		elseif activeMode == "deleteDoor" then
			if hitElement ~= oldHitElement then
				unuseDoorHover()

				if hitElement and getElementModel(hitElement) == editorModels.door2 and wallPositions[hitElement] then
					local x, y = unpack(wallPositions[hitElement])
					local door = doorObjects[x .. "," .. y]

					local model = getElementModel(door)
					local doorname = doorTextureNames[model]
					local textures = texturePaths[door]

					if textures and textures[doorname] then
						placedDoor = {x, y, model, doorRotations[door], gettok(textures[doorname], 3, ",")}
					else
						placedDoor = {x, y, model, doorRotations[door], 0}
					end

					deleteDoor(door)
					destroyElement(door)
					doorPositions[door] = nil
					doorObjects[x .. "," .. y] = nil
					activeHitData = ""

					if texturePaths[hitElement] then
						for i = 1, 4 do
							if texturePaths[hitElement]["tile_" .. i] then
								activeHitData = activeHitData .. texturePaths[hitElement]["tile_" .. i] .. ","

								removeTextureFromElement(hitElement, "tile_" .. i)
							else
								activeHitData = activeHitData .. ","
							end
						end
					end

					setElementModel(hitElement, editorModels.straight)
				end

				oldHitElement = hitElement
			end
		elseif activeMode == "setDoor" then
			local openingAngle = false

			if hitElement then
				local model = getElementModel(hitElement)
				local x, y = getElementPosition(hitElement)
				local rz = select(3, getElementRotation(hitElement))

				if model == editorModels.base or model == editorModels.straight or model == editorModels.door2 then
					local angle = math.atan2(hitY - y, hitX - x) - math.rad(rz)

					if angle < -math.pi then
						angle = angle + math.pi * 2
					end

					if angle > 0 then
						openingAngle = 90
					else
						openingAngle = -90
					end
				end
			end

			if hitElement ~= oldHitElement or openingAngle ~= hoverElemData then
				if hitElement ~= oldHitElement then
					unuseDoorHover(hitElement)
				elseif hitElement then
					local model = getElementModel(hitElement)

					if model == editorModels.door2 and not baseWallPositions[hitElement] then
						local dat = split(selectedItem, "/")
						local x, y = unpack(wallPositions[hitElement])
						local door = doorObjects[x .. "," .. y]

						if door then
							doorPositions[door] = nil
							deleteDoor(door)
							destroyElement(door)
							doorObjects[x .. "," .. y] = nil
						end

						createDoor(x, y, doorIdModels[dat[1]], openingAngle, dat[2])
					end
				end

				if openingAngle ~= hoverElemData then
					hoverElemData = openingAngle

					if baseWallPositions[hitElement] then
						local dat = split(selectedItem, "/")
						local rz = select(3, getElementRotation(hitElement))

						if not activeHitData then
							local textures = {}

							if texturePaths[hitElement] then
								if texturePaths[hitElement]["tile_1"] then
									textures[1] = texturePaths[hitElement]["tile_1"]
								end

								if texturePaths[hitElement]["tile_2"] then
									textures[2] = texturePaths[hitElement]["tile_2"]
								end
							end

							activeHitData = {rz, textures}
						end

						createBaseDoor({false, hitElement, dat[2], openingAngle, doorIdModels[dat[1]], rz})
					end
				end

				if hitElement ~= oldHitElement then
					if hitElement then
						local model = getElementModel(hitElement)
						local rz = select(3, getElementRotation(hitElement))
						local dat = split(selectedItem, "/")

						if baseWallPositions[hitElement] then
							if not activeHitData then
								local textures = {}

								if texturePaths[hitElement] then
									if texturePaths[hitElement]["tile_1"] then
										textures[1] = texturePaths[hitElement]["tile_1"]
									end

									if texturePaths[hitElement]["tile_2"] then
										textures[2] = texturePaths[hitElement]["tile_2"]
									end
								end

								activeHitData = {rz, textures}
							end

							createBaseDoor({false, hitElement, dat[2], openingAngle, doorIdModels[dat[1]], rz})
						elseif model == editorModels.straight then
							activeHitData = ""

							if texturePaths[hitElement] then
								for i = 1, 4 do
									if texturePaths[hitElement]["tile_" .. i] then
										activeHitData = activeHitData .. texturePaths[hitElement]["tile_" .. i] .. ","

										removeTextureFromElement(hitElement, "tile_" .. i)
									else
										activeHitData = activeHitData .. ","
									end
								end
							end

							createDoor(wallPositions[hitElement][1], wallPositions[hitElement][2], doorIdModels[dat[1]], openingAngle, dat[2])
							setElementModel(hitElement, editorModels.door2)
						elseif model == editorModels.door2 then
							local x, y = unpack(wallPositions[hitElement])
							local door = doorObjects[x .. "," .. y]

							local model = getElementModel(door)
							local doorname = doorTextureNames[model]
							local textures = texturePaths[door]

							if textures and textures[doorname] then
								placedDoor = {x, y, model, doorRotations[door], gettok(textures[doorname], 3, ",")}
							else
								placedDoor = {x, y, model, doorRotations[door], 0}
							end

							deleteDoor(door)
							destroyElement(door)
							doorPositions[door] = nil

							createDoor(x, y, doorIdModels[dat[1]], openingAngle, dat[2])
						end
					end

					oldHitElement = hitElement
				end
			end
		elseif activeMode == "deleteWindow" then
			local model = hitElement and getElementModel(hitElement)
			local tile = 0

			if hitElement and model == editorModels.base then
				local rz = select(3, getElementRotation(hitElement))

				if rz == 0 or rz == 180 then
					tile = math.floor((hitY - editorY) / oneTileSize * 2) + 1.5
				else
					tile = math.floor((hitX - editorX) / oneTileSize * 2) + 1.5
				end
			end

			if oldHitElement ~= hitElement or oldWindowTile ~= tile then
				unuseWindowHover()

				if hitElement and model == editorModels.base then
					local rz = select(3, getElementRotation(hitElement))
					local x, y = 0, 0

					if rz == 0 or rz == 180 then
						x = baseWallPositions[hitElement][1] * 2 + 1
						y = tile
					else
						x = tile
						y = baseWallPositions[hitElement][2] * 2 + 1
					end

					local obj = windowObjects[x .. "," .. y]

					if obj then
						hoverElemData = {x, y, rz}
						activeHitData = texturePaths[obj]["tile_1"]
						destroyWindow(x, y)
					end
				end

				oldWindowTile, oldHitElement = tile, hitElement
			end
		elseif activeMode == "setWindow" then
			local model = hitElement and getElementModel(hitElement)
			local tile = 0

			if hitElement and model == editorModels.base then
				local rz = select(3, getElementRotation(hitElement))

				if rz == 0 or rz == 180 then
					tile = math.floor((hitY - editorY) / oneTileSize * 2) + 1.5
				else
					tile = math.floor((hitX - editorX) / oneTileSize * 2) + 1.5
				end
			end

			if oldHitElement ~= hitElement or oldWindowTile ~= tile then
				unuseWindowHover()

				if hitElement and model == editorModels.base then
					local rz = select(3, getElementRotation(hitElement))
					local x, y = 0, 0

					if rz == 0 or rz == 180 then
						x = baseWallPositions[hitElement][1] * 2 + 1
						y = tile
					else
						x = tile
						y = baseWallPositions[hitElement][2] * 2 + 1
					end

					hoverElemData = {x, y, rz}

					local obj = windowObjects[x .. "," .. y]

					if not obj then
						createWindow(x, y, rz, selectedItem)
						oldHitElement = hitElement
					else
						activeHitData = texturePaths[obj]["tile_1"]
						applyTextureToElement(obj, "tile_1", "window", "normal", tonumber(selectedItem))
					end
				end

				oldWindowTile, oldHitElement = tile, hitElement
			end
		elseif activeMode == "setCeil" then
			if hitElement and ceilPositions[hitElement] then
				local x, y = getElementPosition(hitElement)
				local angle = math.deg(math.atan2(hitY - y, hitX - x))

				if activeTileX and not selectedTileX then
					activeTiles[activeTileX .. "," .. activeTileY .. "," .. activeTileLine] = false
				end

				if angle <= -90 or angle > 180 then
					if selectedTileAxis ~= "y" then
						activeTileLine = 3
					end
				elseif angle > -90 and angle <= 0 then
					if selectedTileAxis ~= "x" then
						activeTileLine = 4
					end
				elseif angle > 0 and angle <= 90 then
					if selectedTileAxis ~= "y" then
						activeTileLine = 5
					end
				elseif angle > 90 and angle <= 180 then
					if selectedTileAxis ~= "x" then
						activeTileLine = 6
					end
				end

				activeTileX, activeTileY = ceilPositions[hitElement][1], ceilPositions[hitElement][2]

				if not selectedTileX then
					activeTiles[activeTileX .. "," .. activeTileY .. "," .. activeTileLine] = true
				end
			elseif not selectedTileX then
				activeTiles = {}
				activeTileX, activeTileY = false, false
			end
		elseif activeMode == "setFloor" then
			if hitElement and floorPositions[hitElement] then
				local x, y = getElementPosition(hitElement)
				local angle = math.deg(math.atan2(hitY - y, hitX - x))

				if activeTileX and not selectedTileX then
					activeTiles[activeTileX .. "," .. activeTileY .. "," .. activeTileLine] = false
				end

				if angle <= -90 or angle > 180 then
					if selectedTileAxis ~= "y" then
						activeTileLine = 3
					end
				elseif angle > -90 and angle <= 0 then
					if selectedTileAxis ~= "x" then
						activeTileLine = 4
					end
				elseif angle > 0 and angle <= 90 then
					if selectedTileAxis ~= "y" then
						activeTileLine = 5
					end
				elseif angle > 90 and angle <= 180 then
					if selectedTileAxis ~= "x" then
						activeTileLine = 6
					end
				end

				activeTileX, activeTileY = floorPositions[hitElement][1], floorPositions[hitElement][2]

				if not selectedTileX then
					activeTiles[activeTileX .. "," .. activeTileY .. "," .. activeTileLine] = true
				end
			elseif not selectedTileX then
				activeTiles = {}
				activeTileX, activeTileY = false, false
			end
		elseif activeMode == "setWallpaper" then
			hoverWallData = false

			if hit and hitElement then
				hoverWallData = {hitElement, hitX, hitY}
			end
		elseif activeMode == "drawWall_line" or activeMode == "drawWall_rect" or activeMode == "deleteWall_line" or activeMode == "deleteWall_rect" then
			if hitElement and floorPositions[hitElement] then
				local tilePos = floorPositions[hitElement]

				if activeMode == "drawWall_line" or activeMode == "deleteWall_line" then
					if activeTileX and not selectedTileX then
						activeTiles[activeTileX .. "," .. activeTileY .. "," .. activeTileLine] = false
					end

					local x, y = getElementPosition(hitElement)
					local angle = math.deg(math.atan2(hitY - y, hitX - x)) + 45

					if angle > 360 then
						angle = angle - 360
					end

					if angle <= -90 or angle > 180 then
						if selectedTileAxis ~= "y" then
							activeTileLine = 1
						end
					elseif angle > -90 and angle <= 0 then
						if selectedTileAxis ~= "x" then
							activeTileLine = 2
						end
					elseif angle > 0 and angle <= 90 then
						if selectedTileAxis ~= "y" then
							activeTileLine = 3
						end
					elseif angle > 90 and angle <= 180 then
						if selectedTileAxis ~= "x" then
							activeTileLine = 4
						end
					end
				end

				if selectedTileX then
					if activeMode == "drawWall_line" or activeMode == "deleteWall_line" then
						activeTileX, activeTileY = tilePos[1], tilePos[2]
					else
						if activeMode == "drawWall_rect" or activeMode == "deleteWall_rect" then
							activeTileX, activeTileY = tilePos[1], tilePos[2]
							activeTiles[selectedTileX .. "," .. selectedTileY] = true
						end
					end
				elseif activeMode == "drawWall_line" or activeMode == "deleteWall_line" then
					activeTileX, activeTileY = tilePos[1], tilePos[2]
					activeTiles[activeTileX .. "," .. activeTileY .. "," .. activeTileLine] = true
				else
					if activeMode == "drawWall_rect" or activeMode == "deleteWall_rect" then
						if activeTileX then
							for i = 1, 4 do
								activeTiles[activeTileX .. "," .. activeTileY .. "," .. i] = false
							end
						end

						activeTileX, activeTileY = tilePos[1], tilePos[2]

						for i = 1, 4 do
							activeTiles[activeTileX .. "," .. activeTileY .. "," .. i] = true
						end
					end
				end
			else
				activeTiles = {}
				activeTileX, activeTileY = false, false
			end
		end

		drawGrid()
		drawGUI()
	end

	if activeButton ~= oldActiveButton and activeButton then
		playSoundEx("files/sounds/highlight.mp3")
	end
end

function onEditorKeyHandler(key, press)
	if key == "mouse1" and not press and movedFurniture and movedFurniture[8] == true then
		if movedFurniture[9] then
			cursorRelPos = false
			setCursorPosition(movedFurniture[9] + movedFurniture[1], movedFurniture[10] + movedFurniture[2])
		end

		setCursorAlpha(255)
	elseif activeMode ~= "test" then
		if cursorY > screenY - menuHeight then
			if activeSubMenu == "ceil" then
				if #availableTextures.ceil.normal > menuItemNum then
					if key == "mouse_wheel_up" then
						menuOffset.ceil.normal = menuOffset.ceil.normal - 1

						if menuOffset.ceil.normal < 0 then
							menuOffset.ceil.normal = 0
						end
					elseif key == "mouse_wheel_down" then
						menuOffset.ceil.normal = menuOffset.ceil.normal + 1

						if menuOffset.ceil.normal > #availableTextures.ceil.normal - menuItemNum then
							menuOffset.ceil.normal = #availableTextures.ceil.normal - menuItemNum
						end
					end
				end
			elseif activeMenu == "walls" and activeSubMenu ~= "drawing" then
				if #availableTextures.wall[activeSubMenu] > menuItemNum then
					if key == "mouse_wheel_up" then
						menuOffset.wall[activeSubMenu] = menuOffset.wall[activeSubMenu] - 1

						if menuOffset.wall[activeSubMenu] < 0 then
							menuOffset.wall[activeSubMenu] = 0
						end
					elseif key == "mouse_wheel_down" then
						menuOffset.wall[activeSubMenu] = menuOffset.wall[activeSubMenu] + 1

						if menuOffset.wall[activeSubMenu] > #availableTextures.wall[activeSubMenu] - menuItemNum then
							menuOffset.wall[activeSubMenu] = #availableTextures.wall[activeSubMenu] - menuItemNum
						end
					end
				end
			elseif activeMenu == "floors" then
				if #availableTextures.floor[activeSubMenu] > menuItemNum then
					if key == "mouse_wheel_up" then
						menuOffset.floor[activeSubMenu] = menuOffset.floor[activeSubMenu] - 1

						if menuOffset.floor[activeSubMenu] < 0 then
							menuOffset.floor[activeSubMenu] = 0
						end
					elseif key == "mouse_wheel_down" then
						menuOffset.floor[activeSubMenu] = menuOffset.floor[activeSubMenu] + 1

						if menuOffset.floor[activeSubMenu] > #availableTextures.floor[activeSubMenu] - menuItemNum then
							menuOffset.floor[activeSubMenu] = #availableTextures.floor[activeSubMenu] - menuItemNum
						end
					end
				end
			elseif activeSubMenu == "windows" then
				if #availableTextures.window.normal > menuItemNum then
					if key == "mouse_wheel_up" then
						menuOffset.window.normal = menuOffset.window.normal - 1

						if menuOffset.window.normal < 0 then
							menuOffset.window.normal = 0
						end
					elseif key == "mouse_wheel_down" then
						menuOffset.window.normal = menuOffset.window.normal + 1

						if menuOffset.window.normal > #availableTextures.window.normal - menuItemNum then
							menuOffset.window.normal = #availableTextures.window.normal - menuItemNum
						end
					end
				end
			elseif activeSubMenu == "doors" then
				local sum = #availableTextures.door["1"] + #availableTextures.door["2"] + #availableTextures.door["3"] + #availableTextures.door["4"] + 4 + 1

				if sum > menuItemNum then
					if key == "mouse_wheel_up" then
						menuOffset.door["1"] = menuOffset.door["1"] - 1

						if menuOffset.door["1"] < 0 then
							menuOffset.door["1"] = 0
						end
					elseif key == "mouse_wheel_down" then
						menuOffset.door["1"] = menuOffset.door["1"] + 1

						if menuOffset.door["1"] > sum - menuItemNum then
							menuOffset.door["1"] = sum - menuItemNum
						end
					end
				end
			elseif activeMenu == "furnitures" then
				if #availableFurnitures[activeSubMenu] > menuItemNum then
					if key == "mouse_wheel_up" then
						menuOffset.furnitures[activeSubMenu] = menuOffset.furnitures[activeSubMenu] - 1

						if menuOffset.furnitures[activeSubMenu] < 0 then
							menuOffset.furnitures[activeSubMenu] = 0
						end
					elseif key == "mouse_wheel_down" then
						menuOffset.furnitures[activeSubMenu] = menuOffset.furnitures[activeSubMenu] + 1

						if menuOffset.furnitures[activeSubMenu] > #availableFurnitures[activeSubMenu] - menuItemNum then
							menuOffset.furnitures[activeSubMenu] = #availableFurnitures[activeSubMenu] - menuItemNum
						end
					end
				end
			end
		elseif key == "mouse_wheel_up" then
			cameraZoom = cameraZoom - 1

			if cameraZoom < 3 then
				cameraZoom = 3
			end

			orbitCamera()
		elseif key == "mouse_wheel_down" then
			cameraZoom = cameraZoom + 1

			if cameraZoom > 75 then
				cameraZoom = 75
			end

			orbitCamera()
		else
			if (key == "mouse2" or key == "mouse3" or key == "mouse1" and getKeyState("lshift")) and press then
				local cx, cy = getCursorPosition()

				cursorRelPos = {cx, cy}
				cursorAbsPos = {cx * screenX, cy * screenY}

				setCursorAlpha(0)
			elseif (key == "mouse2" or key == "mouse3" or key == "mouse1" or key == "lshift") and not press then
				if cursorAbsPos then
					if not getKeyStateEx() then
						setCursorPosition(cursorAbsPos[1], cursorAbsPos[2])
						cursorRelPos = false
						cursorAbsPos = false
						setCursorAlpha(255)
					end
				end
			end
		end
	end
end

function onEditorCursorMove(x, y)
	if x and y then
		if movedFurniture and movedFurniture[8] and selectedFurniture then
			if cursorRelPos and cursorRelPos[2] then
				y = y - cursorRelPos[2]

				setCursorPosition(screenX / 2, screenY / 2)
				cursorRelPos = {0.5, 0.5}

				local z = movedFurniture[7] - y * cameraZoom * 0.75

				if z < editorZ - 3.5 then
					z = editorZ - 3.5
				end

				if z > editorZ + 7 then
					z = editorZ + 7
				end

				movedFurniture[7] = z
			end
		elseif getKeyState("mouse2") or getKeyStateEx() then
			if cursorRelPos then
				x = (x - cursorRelPos[1]) * (screenX / screenY)
				y = y - cursorRelPos[2]

				x = -x
				y = -y

				setCursorPosition(screenX / 2, screenY / 2)
				cursorRelPos = {0.5, 0.5}

				if getKeyStateEx() then
					cameraYaw = cameraYaw + x * cameraZoom
					cameraPitch = cameraPitch + y * -cameraZoom

					if cameraPitch >= 89.9 then
						cameraPitch = 89.9
					elseif cameraPitch <= 0 then
						cameraPitch = 0
					end

					orbitCamera()
				else
					local yaw = math.rad(cameraYaw)
					local dist = cameraZoom * 0.25

					cameraPivot[1] = cameraPivot[1] + y * dist * math.cos(yaw) - x * dist * math.sin(yaw)
					cameraPivot[2] = cameraPivot[2] + y * dist * math.sin(yaw) + x * dist * math.cos(yaw)

					if cameraPivot[1] < editorZone[1] then
						cameraPivot[1] = editorZone[1]
					elseif cameraPivot[1] > editorZone[3] then
						cameraPivot[1] = editorZone[3]
					end

					if cameraPivot[2] < editorZone[2] then
						cameraPivot[2] = editorZone[2]
					elseif cameraPivot[2] > editorZone[4] then
						cameraPivot[2] = editorZone[4]
					end

					orbitCamera()
				end
			end
		end

		if getKeyState("mouse1") then
			if activeMode == "setFloor" or activeMode == "setCeil" then
				activeTiles = {}

				if selectedTileX and activeTileX then
					loopTiles(activizeTile)

					if activeTileX ~= lastActiveTileX or activeTileY ~= lastActiveTileY then
						playSoundEx("files/sounds/greenline.mp3")
						lastActiveTileX = activeTileX
						lastActiveTileY = activeTileY
					end
				end
			elseif activeMode == "setWallpaper" then
				if hoverWallData then
					setWallpaper()
				end
			elseif activeMode == "drawWall_line" or activeMode == "drawWall_rect" or activeMode == "deleteWall_line" or activeMode == "deleteWall_rect" then
				activeTiles = {}

				if selectedTileX and activeTileX then
					if not (getKeyState("lshift") and getKeyState("mouse1")) then
						if activeMode == "drawWall_line" or activeMode == "deleteWall_line" and selectedTileAxis then
							loopLineTiles(activizeTiles)
						elseif activeMode == "deleteWall_rect" then
							if activeTileX ~= lastActiveTileX or activeTileY ~= lastActiveTileY then
								playSoundEx("files/sounds/greenline.mp3")
								lastActiveTileX = activeTileX
								lastActiveTileY = activeTileY
							end

							local minX = math.min(selectedTileX, activeTileX)
							local minY = math.min(selectedTileY, activeTileY)
							local maxX = math.max(selectedTileX, activeTileX)
							local maxY = math.max(selectedTileY, activeTileY)

							for x = minX, maxX do
								for y = minY, maxY do
									for i = 1, 4 do
										activizeTile(x, y, i)
									end
								end
							end
						elseif activeMode == "drawWall_rect" then
							if activeTileX ~= lastActiveTileX or activeTileY ~= lastActiveTileY then
								playSoundEx("files/sounds/greenline.mp3")
								lastActiveTileX = activeTileX
								lastActiveTileY = activeTileY
							end

							if activeTileX == selectedTileX and activeTileY == selectedTileY then
								for i = 1, 4 do
									activizeTile(selectedTileX, selectedTileY, i)
								end
							else
								local minX = math.min(selectedTileX, activeTileX)
								local minY = math.min(selectedTileY, activeTileY)
								local maxX = math.max(selectedTileX, activeTileX)
								local maxY = math.max(selectedTileY, activeTileY)

								if not (minX == maxX or minY == maxY) then
									if minX - 1 > 0 then
										for i = minY, maxY do
											activizeTile(minX, i, 2)
											activizeTile(minX, i, 4)
										end
									end

									if maxX < editableX then
										for i = minY, maxY do
											activizeTile(maxX, i, 2)
											activizeTile(maxX, i, 4)
										end
									end

									if minY - 1 > 0 then
										for i = minX, maxX do
											activizeTile(i, minY, 1)
											activizeTile(i, minY, 3)
										end
									end

									if maxY < editableY then
										for i = minX, maxX do
											activizeTile(i, maxY, 1)
											activizeTile(i, maxY, 3)
										end
									end

									activeTiles[maxX .. "," .. maxY .. "," .. 4] = false
									activeTiles[maxX .. "," .. maxY .. "," .. 3] = false
									activeTiles[minX .. "," .. minY .. "," .. 1] = false
									activeTiles[minX .. "," .. minY .. "," .. 2] = false
									activeTiles[minX .. "," .. maxY .. "," .. 4] = false
									activeTiles[minX .. "," .. maxY .. "," .. 1] = false
									activeTiles[maxX .. "," .. minY .. "," .. 3] = false
									activeTiles[maxX .. "," .. minY .. "," .. 2] = false

									if minX - 1 <= 0 then
										if minY - 1 > 0 then
											activizeTile(minX, minY, 3)
											activizeTile(minX, minY, 1)
										end

										if maxY < editableY then
											activizeTile(minX, maxY, 3)
											activizeTile(minX, maxY, 1)
										end
									end

									if editableX <= maxX then
										if minY - 1 > 0 then
											activizeTile(maxX, minY, 3)
											activizeTile(maxX, minY, 1)
										end

										if maxY < editableY then
											activizeTile(maxX, maxY, 3)
											activizeTile(maxX, maxY, 1)
										end
									end

									if minY - 1 <= 0 then
										if minX - 1 > 0 then
											activizeTile(minX, minY, 2)
											activizeTile(minX, minY, 4)
										end

										if maxX < editableX then
											activizeTile(maxX, minY, 2)
											activizeTile(maxX, minY, 4)
										end
									end

									if editableY <= maxY then
										if minX - 1 > 0 then
											activizeTile(minX, maxY, 2)
											activizeTile(minX, maxY, 4)
										end

										if maxX < editableX then
											activizeTile(maxX, maxY, 2)
											activizeTile(maxX, maxY, 4)
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function tryToSaveInterior()
	if not saveInProgress then
		saveInProgress = true
		setMode("looking")

		if saveTick and getTickCount() - saveTick < 2500 then
			exports.sm_accounts:showInfo("e", "Ilyen gyorsan nem tudsz menteni!")
			return
		end

		saveTick = getTickCount()

		if cashCosts - lastCashCosts > 0 and cashCosts - lastCashCosts > getElementData(localPlayer, "char.Money") then
			exports.sm_accounts:showInfo("e", "Nincs elég pénzed!")
			saveInProgress = false
			return
		end

		local data = {}

		data.baseWalls = {}

		for i = 1, #baseWalls do
			local obj = baseWalls[i]

			if texturePaths[obj] then
				local pos = table.concat(baseWallPositions[obj], ",")

				for k, v in pairs(texturePaths[obj]) do
					table.insert(data.baseWalls, {pos, smallTextureName(k), smallPathName(v)})
				end
			end
		end

		data.baseFloors = {}

		for i = 1, #floors do
			local obj = floors[i]

			if texturePaths[obj] then
				local pos = table.concat(floorPositions[obj], ",")

				for k, v in pairs(texturePaths[obj]) do
					table.insert(data.baseFloors, {pos, smallTextureName(k), smallPathName(v)})
				end
			end
		end

		data.baseCeils = {}

		for i = 1, #ceils do
			local obj = ceils[i]

			if texturePaths[obj] then
				local pos = table.concat(ceilPositions[obj], ",")

				for k2, v in pairs(texturePaths[obj]) do
					table.insert(data.baseCeils, {pos, smallTextureName(k2), smallPathName(v)})
				end
			end
		end

		data.walls = {}

		for k, v in pairs(wallObjects) do
			local rz = select(3, getElementRotation(v))
			local dat = {k, rz, getElementModel(v)}

			if texturePaths[v] then
				dat[4] = {}

				local textures = 0

				for k2, v2 in pairs(texturePaths[v]) do
					dat[4][smallTextureName(k2)] = smallPathName(v2)
					textures = textures + 1
				end

				if textures < 1 then
					dat[4] = nil
				end
			end

			table.insert(data.walls, dat)
		end

		data.baseDoor = currentBaseDoor
		data.doors = {}

		for k, v in pairs(doorObjects) do
			local model = getElementModel(v)
			local texture = 0

			if texturePaths[v] then
				texture = utf8.sub(texturePaths[v][doorTextureNames[model]], 8)
			end

			table.insert(data.doors, {k, model, texture, doorRotations[v]})
		end

		data.windows = {}

		for k, v in pairs(windowObjects) do
			local rz = select(3, getElementRotation(v))

			table.insert(data.windows, {k, utf8.sub(texturePaths[v]["tile_1"], 15), rz})
		end

		data.furnitures = {}

		for k, v in pairs(placedFurnitures) do
			local x, y, z = getElementPosition(k)
			local rz = select(3, getElementRotation(k))

			table.insert(data.furnitures, {getElementModel(k), x, y, z, rz})
		end

		data.costs = cashCosts

		local dynamicData = false

		for k, v in pairs(doorStates) do
			if v == "inservice" or v == "unlocked" then
				doorStates[k] = nil
				dynamicData = true
			end
		end

		if dynamicData then
			saveDynamicData()
		end

		triggerServerEvent("interiorEdit:saveInterior", localPlayer, activeInteriorId, toString(data), cashCosts)
	end
end

function onEditorClick(button, state, absX, absY, worldX, worldY, worldZ, clickedElement)
	if getKeyState("lshift") and getKeyState("mouse1") then
		return
	end

	if button == "left" and selectedFurniture and (not clickedElement or not placedFurnitures[clickedElement]) and not activeButton and state == "down" then
		setActiveFurniture(false)
		return
	end

	if not activeButton then
		if button == "left" then
			if state == "down" then
				if activeMode == "looking" then
					if isElement(clickedElement) then
						local model = getElementModel(clickedElement)

						if placedFurnitures[clickedElement] then
							setActiveFurniture(clickedElement)
							return
						end

						if model == 2332 and getElementData(clickedElement, "safeId") then
							if getTickCount() - clickTick > 1000 then
								setActiveFurniture(clickedElement)
								clickTick = getTickCount()
								return
							end
						end

						if model == 2964 and getElementData(clickedElement, "poolTableID") then
							if getTickCount() - clickTick > 1000 then
								setActiveFurniture(clickedElement)
								clickTick = getTickCount()
								return
							end
						end
					end
				end
			end
		end
	end

	if activeButton and state == "down" then
		if button == "left" then
			local selected = split(activeButton, ":")

			if selected[#selected] == "selectSound" then
				playSoundEx("files/sounds/select.mp3")
			end

			if selected[1] == "promptYes" then
				if activePrompt[1] == "billiard" then
					triggerServerEvent("interiorEdit:placeBilliard", localPlayer, activePrompt)
				end

				if activePrompt[1] == "safe" then
					triggerServerEvent("interiorEdit:placeSafe", localPlayer, activePrompt)
				end

				if activePrompt[1] == "buyPPFurniture" then
					triggerServerEvent("interiorEdit:buyPPFurniture", localPlayer, activeInteriorId, activePrompt[3])
				end

				if activePrompt[1] == "exit" then
					triggerServerEvent("interiorEdit:exitInterior", localPlayer, true)
				end

				activePrompt = false
			elseif selected[1] == "promptNo" then
				activePrompt = false
			elseif selected[1] == "exit" then
				activePrompt = {"exit", "Tényleg szeretnél #d75959mentés nélkül#ffffff kilépni?"}
			elseif selected[1] == "save" then
				tryToSaveInterior()
			elseif selected[1] == "main" then
				if activeMenu ~= selected[2] then
					setMode("looking")

					if activeSubMenu == "ceil" then
						showCeil(false)
						showFloor(true)
						reverseCamera(false)
					end

					activeMenu = selected[2]
					activeSubMenu = mainCategories[activeMenu]

					playSoundEx("files/sounds/category.mp3")
				end
			elseif selected[1] == "sub" then
				if activeSubMenu ~= selected[2] then
					setMode("looking")

					if selected[2] == "ceil" then
						showCeil(true)
						showFloor(false)
						reverseCamera(true)
					elseif activeSubMenu == "ceil" then
						showCeil(false)
						showFloor(true)
						reverseCamera(false)
					end

					activeSubMenu = selected[2]

					if activeSubMenu == "premium" then
						playSoundEx("files/sounds/categorypremium.mp3")
					else
						playSoundEx("files/sounds/category.mp3")
					end
				end
			elseif selected[1] == "mode" then
				modeClick(selected)
			elseif selected[1] == "deleteFurniture" then
				if isElement(selectedFurniture) then
					local model = getElementModel(selectedFurniture)

					if model == 2332 or model == 2964 then
						exports.sm_accounts:showInfo("e", "Ezt nem törölheted!")
						return
					end

					if useableTvs[model] then
						--ppFurnitures[model] = (ppFurnitures[model] or 0) - 1
						addCashCosts(-prices.furnitures[model])
					else
						addCashCosts(-prices.furnitures[model])
					end

					placedFurnitures[selectedFurniture] = nil
					destroyElement(selectedFurniture)
					setActiveFurniture(false)

					playSoundEx("files/sounds/deletebasic.mp3")
				end
			elseif selected[1] == "placeOnFloor" then
				if isElement(selectedFurniture) then
					local x, y = getElementPosition(selectedFurniture)

					setElementPosition(selectedFurniture, x, y, editorZ + getElementDistanceFromCentreOfMassToBaseOfModel(selectedFurniture) + oneTileWidth / 2)
				end
			elseif selected[1] == "rotateMode" then
				if selected[2] == "on" then
					furnitureRotateMode = true
				else
					furnitureRotateMode = false
				end
			elseif selected[1] == "infoState" then
				infoGuiState = not infoGuiState
			elseif selected[1] == "infoPage" then
				infoPages[activeMenu] = tonumber(selected[2]) or 1
			elseif selected[1] == "sound" then
				soundState = not soundState

				if soundState then
					playSound("files/sounds/select.mp3")
				end
			elseif selected[1] == "music" then
				musicState = not musicState

				destroyElement(bcgMusic)
				bcgMusic = false

				if musicState then
					startBcgMusic()
				end
			elseif selected[1] == "snap" then
				if selected[2] == "0" then
					snapMove = false
				else
					snapMove = tonumber(selected[2])
				end
			elseif selected[1] == "snapr" then
				if selected[2] == "0" then
					snapRotation = false
				else
					snapRotation = tonumber(selected[2])
				end
			elseif selected[1] == "side" then
				sideGuiState = not sideGuiState

				if sideGuiState then
					sideGuiX = 0
				else
					sideGuiX = -1000
				end
			elseif selected[1] == "grid" then
				gridVisible = not gridVisible
			elseif selected[1] == "day" then
				setDaytime()
				playSound("files/sounds/dayandnightswitch.mp3")
			elseif selected[1] == "test" then
				setTest()
			end
		end
	elseif activeMode ~= "looking" and button == "right" then
		if state == "down" and selectedTileX then
			selectedTileX, selectedTileY = false, false
			selectedTileLine = false
			activeTiles = {}
		end
	elseif activeMode == "placeFurniture" then
		if canPlaceFurniture and button == "left" and state == "down" then
			local model = getElementModel(activeFurniture)
			local x, y, z = getElementPosition(activeFurniture)
			local rz = select(3, getElementRotation(activeFurniture))

			if model == 2332 then
				destroyElement(activeFurniture)
				activeFurniture = false

				setMode("looking")
				activePrompt = {"safe", "Tényleg szeretnéd megvenni ezt a #3d7abcszéfet#ffffff " .. pricesForDraw.furnitures[2332] .. " #3d7abcPP#ffffff-ért?", x, y, z, rz}
			elseif model == 2964 then
				destroyElement(activeFurniture)
				activeFurniture = false

				setMode("looking")
				activePrompt = {"billiard", "Tényleg szeretnéd megvenni ezt a #3d7abcasztalt#ffffff " .. pricesForDraw.furnitures[2964] .. " #3d7abcPP#ffffff-ért?", x, y, z, rz}
			else
				placedFurnitures[activeFurniture] = true

				setElementCollisionsEnabled(activeFurniture, true)

				if useableTvs[model] then
					ppFurnitures[model] = (ppFurnitures[model] or 0) + 1
				else
					addCashCosts(prices.furnitures[model])
				end

				activeFurniture = false
				setMode("looking")
			end
		end
	elseif activeMode == "deleteDoor" then
		if button == "left" and state == "down" then
			if wallPositions[oldHitElement] then
				local pos = table.concat(wallPositions[oldHitElement], ",")

				if doorStates[pos] then
					if doorStates[pos] == "damaged" then
						addCashCosts(prices.lock)
						exports.sm_accounts:showInfo("i", "Az ajtó zárja sérült volt, és " .. prices.lock .. "$-ba került megjavítani.")
						doorStates[pos] = "inservice"
					else
						doorStates[pos] = "unlocked"
					end
				end
			end

			oldHitElement = false
			hoverElemData = false
			activeHitData = false
			placedDoor = false

			playSoundEx("files/sounds/deletebasic.mp3")
		end
	elseif activeMode == "setDoor" then
		if button == "left" and state == "down" then
			if baseWallPositions[oldHitElement] then
				setCurrentBaseDoor()
			end

			if wallPositions[oldHitElement] then
				local pos = table.concat(wallPositions[oldHitElement], ",")

				if doorStates[pos] == "damaged" then
					addCashCosts(prices.lock)
					exports.sm_accounts:showInfo("s", "Sikeresen megjavítottad az ajtó zárját!")
					doorStates[pos] = "inservice"
				else
					doorStates[pos] = "unlocked"
				end
			end

			oldHitElement = false
			hoverElemData = false
			activeHitData = false
			placedDoor = false

			--playSoundEx("files/sounds/buy" .. math.random(2) .. ".mp3")
		end
	elseif activeMode == "setWindow" or activeMode == "deleteWindow" then
		if button == "left" and state == "down" then
			oldHitElement = false
			oldWindowTile = false
			hoverElemData = false
			activeHitData = false

			if activeMode == "setWindow" then
				--playSoundEx("files/sounds/buy" .. math.random(2) .. ".mp3")
			else
				--playSoundEx("files/sounds/deletebasic.mp3")
			end
		end
	elseif activeMode == "setCeil" and button == "left" then
		if state == "down" then
			if activeTileX then
				selectedTileX, selectedTileY, selectedTileLine = activeTileX, activeTileY, activeTileLine
			end
		else
			if selectedTileX then
				--playSoundEx("files/sounds/buy" .. math.random(2) .. ".mp3")
				loopTiles(applyCeilTexture)
			end

			selectedTileX, selectedTileY = false, false
			selectedTileLine, selectedTileAxis = false, false
			activeTiles = {}
		end
	elseif activeMode == "setFloor" and button == "left" then
		if state == "down" then
			if activeTileX then
				selectedTileX, selectedTileY, selectedTileLine = activeTileX, activeTileY, activeTileLine
			end
		else
			if selectedTileX then
				---playSoundEx("files/sounds/buy" .. math.random(2) .. ".mp3")
				loopTiles(applyFloorTexture)
			end

			selectedTileX, selectedTileY = false, false
			selectedTileLine, selectedTileAxis = false, false
			activeTiles = {}
		end
	elseif activeMode == "setWallpaper" then
		if button == "left" and state == "down" and hoverWallData then
			setWallpaper()
		end
	elseif (activeMode == "drawWall_line" or activeMode == "drawWall_rect" or activeMode == "deleteWall_line" or activeMode == "deleteWall_rect") and button == "left" then
		if state == "down" then
			if activeTileX then
				selectedTileX, selectedTileY = activeTileX, activeTileY

				if activeMode == "drawWall_line" or activeMode == "deleteWall_line" then
					selectedTileLine = activeTileLine

					if activeTileLine == 1 or activeTileLine == 3 then
						selectedTileAxis = "x"
					else
						selectedTileAxis = "y"
					end
				end
			end
		else
			if selectedTileX and activeTileX then
				local minX = math.min(selectedTileX, activeTileX)
				local minY = math.min(selectedTileY, activeTileY)
				local maxX = math.max(selectedTileX, activeTileX)
				local maxY = math.max(selectedTileY, activeTileY)

				if activeMode == "deleteWall_line" then
					if selectedTileAxis == "x" then
						for i = minX, maxX do
							deleteWall(i, selectedTileY)
						end
					elseif selectedTileAxis == "y" then
						for i = minY, maxY do
							deleteWall(selectedTileX, i)
						end
					else
						deleteWall(activeTileX, activeTileY)
					end

					playSoundEx("files/sounds/deletewall.mp3")
				elseif activeMode == "deleteWall_rect" then
					for x = minX, maxX do
						for y = minY, maxY do
							deleteWall(x, y)
						end
					end

					playSoundEx("files/sounds/deletewall.mp3")
				elseif activeMode == "drawWall_line" then
					loopLineTiles(placeLineWalls)
				elseif activeMode == "drawWall_rect" then
					if not (minX == maxX or minY == maxY) then
						if minX - 1 > 0 then
							for i = minY, maxY do
								createWall(minX, i, 0, false, false, true)
							end
						end

						if maxX < editableX then
							for i = minY, maxY do
								createWall(maxX, i, 0, false, false, true)
							end
						end

						if minY - 1 > 0 then
							for i = minX, maxX do
								createWall(i, minY, 90, false, false, true)
							end
						end

						if maxY < editableY then
							for i = minX, maxX do
								createWall(i, maxY, 90, false, false, true)
							end
						end

						if maxX < editableX and maxY < editableY then
							makeCorner(maxX, maxY, 270)
						end

						if minX - 1 > 0 and minY - 1 > 0 then
							makeCorner(minX, minY, 90)
						end

						if minX - 1 > 0 and maxY < editableY then
							makeCorner(minX, maxY, 0)
						end

						if maxX < editableX and minY - 1 > 0 then
							makeCorner(maxX, minY, 180)
						end

						playSoundEx("files/sounds/construct" .. math.random(2) .. ".mp3")
					end
				end
			end

			selectedTileX, selectedTileY = false, false
			selectedTileLine, selectedTileAxis = false, false
			activeTiles = {}
		end
	end
end

function modeClick(selected)
	if selected[2] == "placeFurniture" then
		if activeFurniture and getElementModel(activeFurniture) == selected[3] then
			setMode("looking")
		else
			local model = tonumber(selected[3])

			if useableTvs[model] then
				if (ppThings[model] or 0) - (ppFurnitures[model] or 0) <= 0 then
					activePrompt = {"buyPPFurniture", "Tényleg szeretnéd megvenni ezt a #3d7abcbútordarabot#ffffff " .. pricesForDraw.furnitures[model] .. " #3d7abcPP#ffffff-ért?", model}
					return
				end
			end

			if activeMode ~= "placeFurniture" then
				local objects = getElementsByType("object", getRootElement(), true)

				if model == 2964 then
					for i = 1, #objects do
						if getElementModel(objects[i]) == 2964 then
							exports.sm_accounts:showInfo("e", "Már van egy billárdasztal ebben az interiorban.")
							return
						end
					end
				end

				if #objects - #floors - #baseWalls - #ceils >= 400 then
					exports.sm_accounts:showInfo("e", "Elérted a maximális objektumszámot! (" .. #objects - #floors - #baseWalls - #ceils .. "/400 db)")
					return
				end

				setMode("placeFurniture")

				activeFurniture = createObject(model, 0, 0, 0, 0, 0, furnitureRotation)

				setObjectBreakable(activeFurniture, false)
				setElementDoubleSided(activeFurniture, true)
				setElementCollisionsEnabled(activeFurniture, false)
				setElementInteriorAndDimension(activeFurniture, 1)
			else
				setElementModel(activeFurniture, tonumber(selected[3]))
			end
		end
	elseif selected[2] == "setWallpaper" or selected[2] == "setFloor" or selected[2] == "setCeil" or selected[2] == "setWindow" or selected[2] == "deleteWindow" or selected[2] == "setDoor" or selected[2] == "deleteDoor" then
		if selectedItem == selected[3] then
			setMode("looking")
		else
			selectedItem = selected[3]

			if activeMode ~= selected[2] then
				setMode(selected[2])
			end
		end
	elseif activeMode == selected[2] then
		setMode("looking")
	else
		setMode(selected[2])
	end
end

function showFloor(show)
	for i = 1, #floors do
		setElementInteriorAndDimension(floors[i], show and 1 or 2)
		setElementCollisionsEnabled(floors[i], show)
	end
end

function showCeil(show)
	for i = 1, #ceils do
		setElementInteriorAndDimension(ceils[i], show and 1 or 2)
		setElementCollisionsEnabled(ceils[i], show)
	end
end

function floorMode(state)
	for i = 1, #baseWalls do
		setElementCollisionsEnabled(baseWalls[i], not state)
	end

	for i = 1, #walls do
		setElementCollisionsEnabled(walls[i], not state)
	end

	for k, v in pairs(doorObjects) do
		setElementCollisionsEnabled(v, not state)
	end

	for k, v in pairs(placedFurnitures) do
		setElementCollisionsEnabled(k, not state)
	end
end

function setMode(mode)
	if mode == "drawWall_line" or mode == "drawWall_rect" or mode == "setWindow" or mode == "setDoor" then
		local objects = getElementsByType("object", getRootElement(), true)

		if #objects - #floors - #baseWalls - #ceils >= 400 then
			exports.sm_accounts:showInfo("e", "Elérted a maximális objektumszámot! (" .. #objects - #floors - #baseWalls - #ceils.. "/400 db)")
			return
		end
	end

	if mode ~= activeMode then
		setActiveFurniture(false)
		selectedFurniture = false
	end

	if activeMode == "drawWall_line" or activeMode == "drawWall_rect" or activeMode == "deleteWall_line" or activeMode == "deleteWall_rect" then
		selectedTileX, selectedTileY = false, false
		selectedTileLine = false
		activeTiles = {}
		activeTileX, activeTileY = false, false
		activeTileLine = false
		floorMode(false)
		hoverWallData = false
		hoverElemData = false
		selectedItem = false
	elseif activeMode == "setWallpaper" then
		for k, v in pairs(placedFurnitures) do
			setElementCollisionsEnabled(k, true)
		end

		hoverWallData = false
		selectedItem = false
		placedDoor = false
	elseif activeMode == "setFloor" or activeMode == "setCeil" then
		selectedTileX, selectedTileY = false, false
		selectedTileLine = false
		activeTiles = {}
		activeTileX, activeTileY = false, false
		activeTileLine = false
		hoverWallData = false
		hoverElemData = false
		selectedItem = false
		activeHitData = false
		placedDoor = false
		floorMode(false)
	elseif activeMode == "setWindow" then
		for i = 1, #walls do
			setElementCollisionsEnabled(walls[i], true)
		end

		unuseWindowHover()
		hoverElemData = false
		activeHitData = false
		placedDoor = false
	elseif activeMode == "deleteWindow" then
		for i = 1, #walls do
			setElementCollisionsEnabled(walls[i], true)
		end

		unuseWindowHover()
	elseif activeMode == "setDoor" or activeMode == "deleteDoor" then
		if activeMode == "deleteDoor" then
			for i = 1, #baseWalls do
				setElementCollisionsEnabled(baseWalls[i], true)
			end
		end

		placedDoor = false
		unuseDoorHover()
		placedBaseDoor = false
	elseif activeMode == "placeFurniture" then
		destroyElement(activeFurniture)
		activeFurniture = false
		selectedFurniture = false
	end

	if mode == "drawWall_line" or mode == "drawWall_rect" then
		gridColor = tocolor(61, 122, 188)
		floorMode(true)
	elseif mode == "setWallpaper" then
		for k, v in pairs(placedFurnitures) do
			setElementCollisionsEnabled(k, false)
		end
	elseif mode == "deleteWall_line" or mode == "deleteWall_rect" then
		gridColor = tocolor(215, 89, 89)
		floorMode(true)
	elseif mode == "setFloor" or mode == "setCeil" then
		gridColor = tocolor(61, 122, 188)
		floorMode(true)
	elseif mode == "setWindow" or mode == "deleteWindow" then
		for i = 1, #walls do
			setElementCollisionsEnabled(walls[i], false)
		end
	elseif mode == "deleteDoor" then
		for i = 1, #baseWalls do
			setElementCollisionsEnabled(baseWalls[i], false)
		end
	elseif mode == "test" then
		for k, v in pairs(placedFurnitures) do
			setElementCollisionsEnabled(k, true)
		end
	elseif mode == "looking" then
		selectedItem = false
	end

	activeMode = mode
end

function drawGrid()
	for x = -10, editableX + 10 do
		local x2 = editorX + (x - 1) * oneTileSize
		local x3 = editorX + (x - 0.5) * oneTileSize
		local x4 = editorX + x * oneTileSize

		for y = -10, editableY + 10 do
			local y2 = editorY + (y - 1) * oneTileSize
			local y3 = editorY + (y - 0.5) * oneTileSize
			local y4 = editorY + y * oneTileSize

			if x >= 1 and x <= editableX and y >= 1 and y <= editableY then
				if activeMode == "setFloor" or activeMode == "setCeil" or activeMode == "placeFurniture" or selectedFurniture then
					drawGridLine2(x, y, 3, x, y - 1, 6, x2, y2, x3, y2)
					drawGridLine2(x, y - 1, 5, x, y, 4, x3, y2, x4, y2)
					drawGridLine2(x, y, 3, x - 1, y, 4, x2, y2, x2, y3)
					drawGridLine2(x - 1, y, 5, x, y, 6, x2, y3, x2, y4)
					drawGridLine2(x, y, 3, x, y, 6, x2, y3, x3, y3)
					drawGridLine2(x, y, 5, x, y, 4, x3, y3, x4, y3)
					drawGridLine2(x, y, 3, x, y, 4, x3, y2, x3, y3)
					drawGridLine2(x, y, 5, x, y, 6, x3, y3, x3, y4)
				elseif gridVisible then
					drawGridLine(x, y, 1, x2, y3, x3, y3)
					drawGridLine(x, y, 2, x3, y2, x3, y3)
					drawGridLine(x, y, 3, x3, y3, x4, y3)
					drawGridLine(x, y, 4, x3, y3, x3, y4)
				end
			elseif gridVisible then
				dxDrawLine3D(x2, y2, editorZ + gridOuterZ, x4, y2, editorZ + gridOuterZ, tocolor(255, 255, 255, 175), gridLineSize)
				dxDrawLine3D(x2, y2, editorZ + gridOuterZ, x2, y4, editorZ + gridOuterZ, tocolor(255, 255, 255, 175), gridLineSize)
			end
		end
	end

	if gridVisible then
		dxDrawLine3D(editorX + -11 * oneTileSize, editorY + (editableY + 10) * oneTileSize, editorZ + gridOuterZ, editorX + (editableX + 10) * oneTileSize, editorY + (editableY + 10) * oneTileSize, editorZ + gridOuterZ, tocolor(255, 255, 255, 175), gridLineSize)
		dxDrawLine3D(editorX + (editableX + 10) * oneTileSize, editorY + -11 * oneTileSize, editorZ + gridOuterZ, editorX + (editableX + 10) * oneTileSize, editorY + (editableY + 10) * oneTileSize, editorZ + gridOuterZ, tocolor(255, 255, 255, 175), gridLineSize)
	end
end

function drawGridLine(tileX, tileY, tileLine, x, y, x2, y2)
	local z = editorZ + gridInnerZ

	if activeTiles[tileX .. "," .. tileY .. "," .. tileLine] then
		dxDrawMaterialLine3D(x, y, z, x2, y2, z, gridLine, gridLineSize * 0.015 * 1.5, gridColor, x, y, z + 10)
	else
		dxDrawLine3D(x, y, z, x2, y2, z, gridDefaultColor, gridLineSize)
	end
end

function drawGridLine2(tileX, tileY, tileLine, tileX2, tileY2, edge2, x, y, x2, y2)
	local z = editorZ + gridInnerZ

	if activeTiles[tileX .. "," .. tileY .. "," .. tileLine] or activeTiles[tileX2 .. "," .. tileY2 .. "," .. edge2] then
		dxDrawMaterialLine3D(x, y, z, x2, y2, z, gridLine, gridLineSize * 0.015 * 1.5, gridColor, x, y, z + 10)
	else
		dxDrawLine3D(x, y, z, x2, y2, z, gridDefaultColor, gridLineSize)
	end
end

function drawIconText(x, y, icon, text, seperator, i)
	if seperator then
		dxDrawLine(x + navMargin, y + navMargin, x + navMargin, y + navHeight - navMargin, tocolor(255, 255, 255), 2)
		x = x + navMargin * 2
	end

	local textWidth = dxGetTextWidth(text, 1, Roboto)

	dxDrawImage(x + navMargin, y + navMargin, navHeight - navMargin * 2, navHeight - navMargin * 2, "files/images/" .. icon .. ".png")
	dxDrawText(text, x + navHeight + navMargin, y, 0, y + navHeight, tocolor(255, 255, 255), 1, Roboto, "left", "center")

	if activeMenu == i then
		dxDrawLine(x + navMargin, y - 1 + navHeight, x + navHeight + textWidth + navMargin, y - 1 + navHeight, tocolor(61, 122, 188), 2)
	else
		if cursorX >= x and cursorY >= y and cursorX <= x + navHeight + textWidth + navMargin and cursorY <= y + navHeight then
			activeButton = "main:" .. i
			dxDrawLine(x + navMargin, y - 1 + navHeight, x + navHeight + textWidth + navMargin, y - 1 + navHeight, tocolor(61, 122, 188, 200), 2)
		end
	end

	return x + navHeight + textWidth + respc(10)
end

function drawText(x, y, text, i, seperator)
	local textWidth = dxGetTextWidth(text, 1, RobotoL)

	if not seperator then
		dxDrawText(" / ", x + textWidth, y, 0, y + navHeight, tocolor(175, 175, 175), 1, RobotoL, "left", "center")
	end

	if activeSubMenu == i then
		dxDrawText(text, x, y, 0, y + navHeight, tocolor(61, 122, 188), 1, RobotoL, "left", "center")
	elseif cursorX >= x and cursorY >= y and cursorX <= x + textWidth and cursorY <= y + navHeight then
		activeButton = "sub:" .. i
		dxDrawText(text, x, y, 0, y + navHeight, tocolor(255, 255, 255), 1, RobotoL, "left", "center")
	else
		dxDrawText(text, x, y, 0, y + navHeight, tocolor(160, 160, 160), 1, RobotoL, "left", "center")
	end

	if not seperator then
		textWidth = textWidth + navDivWidth
	else
		textWidth = textWidth + navMargin
	end

	return x + textWidth
end

function drawItemRectangle(i, picture, text, buttonName, state, isItem, itemType, topText)
	local x = menuItemWidth * (i - 1) + menuItemMargin
	local y = screenY - menuHeight + menuItemMargin

	local sx = menuItemWidth - menuItemMargin
	local sy = menuItemHeight - menuItemMargin * 2

	if state then
		dxDrawRectangle(x, y, sx, sy, tocolor(61, 122, 188))

		if cursorX >= x and cursorY >= y and cursorX <= menuItemWidth * i and cursorY <= screenY - menuItemMargin then
			activeButton = buttonName
			dxDrawRectangle(x + 2, y + 2, sx - 4, sy - 4, tocolor(80, 80, 80))
		else
			dxDrawRectangle(x + 2, y + 2, sx - 4, sy - 4, tocolor(40, 40, 40))
		end
	elseif cursorX >= x and cursorY >= y and cursorX <= menuItemWidth * i and cursorY <= screenY - menuItemMargin then
		activeButton = buttonName
		dxDrawRectangle(x, y, sx, sy, tocolor(80, 80, 80))
	else
		dxDrawRectangle(x, y, sx, sy, tocolor(40, 40, 40))
	end

	if isItem then
		if itemType == "door" then
			dxDrawImage(x + menuItemMargin + respc(16), y + sy / 2 - (sx - menuItemMargin) / 2, sx - menuItemMargin * 2 - respc(32), sx - menuItemMargin, "files/" .. picture .. ".png")
		elseif itemType then
			dxDrawImageSection(x + respc(12), y + respc(12), sx - respc(24), sx - menuItemMargin - respc(24), 32, 32, 64, 64, "files/" .. picture .. ".png")
		else
			dxDrawImage(x + 2, y + 2, sx - 4, sy - 4, "files/" .. picture .. ".png")
		end
	else
		dxDrawImage(x, y + 2, sx, sx, "files/" .. picture .. ".png")
	end

	if utf8.find(text, "#%x%x%x%x%x%x") then
		dxDrawText(text:gsub("#%x%x%x%x%x%x", ""), x + 1, screenY - menuItemMargin - navIconSize + 1, menuItemWidth * i + 1, screenY - menuItemMargin + 1, tocolor(0, 0, 0), 0.75, Roboto, "center", "center")
		dxDrawText(text, x, screenY - menuItemMargin - navIconSize, menuItemWidth * i, screenY - menuItemMargin, tocolor(255, 255, 255), 0.75, Roboto, "center", "center", false, false, false, true)
	else
		dxDrawText(text, x + 1, screenY - menuItemMargin - navIconSize + 1, menuItemWidth * i + 1, screenY - menuItemMargin + 1, tocolor(0, 0, 0), 0.75, Roboto, "center", "center")
		dxDrawText(text, x, screenY - menuItemMargin - navIconSize, menuItemWidth * i, screenY - menuItemMargin, tocolor(255, 255, 255), 0.75, Roboto, "center", "center")
	end

	if topText then
		dxDrawText(topText, x, y, menuItemWidth * i, y + navIconSize, tocolor(255, 255, 255), 0.75, Roboto, "center", "center")
	end

	return i + 1
end

function drawSideIcon(i, on, off, buttonName, state, tooltipText)
	local x = respc(100) + sideGuiWidth * (i - 1)
	local y = respc(15)

	local iconSize = respc(32)
	local offset = sideGuiWidth / 2 - iconSize / 2

	if cursorX >= x and cursorY >= y and cursorX <= x + sideGuiWidth and cursorY <= y + sideGuiWidth then
		activeButton = buttonName

		dxDrawImage(math.floor(x + offset), math.floor(y + offset), iconSize, iconSize, "files/images/" .. (state and on or off) .. ".png", 0, 0, 0, tocolor(61, 122, 188))

		local textWidth = dxGetTextWidth(tooltipText, 1, RobotoL) + respc(15)

		x = x + textWidth - respc(12)
		y = y + (sideGuiWidth - respc(34)) / 2

		--dxDrawRectangle(x, y, textWidth, respc(34), tocolor(0, 0, 0, 125))

		--dxDrawText(tooltipText, x, y, x + textWidth, y + respc(34), tocolor(255, 255, 255), 1, RobotoL, "center", "center")
		createToolip(tooltipText)
	else
		dxDrawImage(math.floor(x + offset), math.floor(y + offset), iconSize, iconSize, "files/images/" .. (state and on or off) .. ".png")
	end

	return i + 1
end

function createToolip(theText)
	local cx, cy = getCursorPosition()
	cx, cy = cx * screenX, cy * screenY
	if theText then
		local textWidth = dxGetTextWidth(theText, 1, RobotoL)
		dxDrawRectangle(cx, cy, textWidth + respc(40), respc(50), tocolor(50, 50, 50, 230), true)
		dxDrawText(theText, cx, cy, cx + textWidth + respc(40), cy + respc(50) , tocolor(200, 200, 200, 200), 1, RobotoL, "center", "center", false, false, true, true)
	end
end

function drawSideGUI()
	calculateSideGuiSize()

	if cursorX >= screenX-respc(32) and cursorY >= screenY-respc(175) and cursorX <= screenX-respc(32) + sideGuiWidth and cursorY <= screenY-respc(175) + respc(32) then
		activeButton = "side"

		if sideGuiState then
			dxDrawImage(screenX-respc(32), screenY-respc(175), respc(32), respc(32), "files/images/arrow.png", 180, 0, 0, tocolor(61, 122, 188), true)
		else
			dxDrawImage(screenX-respc(32), screenY-respc(175), respc(32), respc(32), "files/images/arrow.png", 0, 0, 0, tocolor(61, 122, 188), true)
		end
	else
		if sideGuiState then
			dxDrawImage(screenX-respc(32), screenY-respc(175), respc(32), respc(32), "files/images/arrow.png", 180, 0, 0, tocolor(200, 200, 200), true)
		else
			dxDrawImage(screenX-respc(32), screenY-respc(175), respc(32), respc(32), "files/images/arrow.png", 0, 0, 0, tocolor(200, 200, 200), true)
		end
	end
	if sideGuiState then
		dxDrawRectangle(0, 0, screenX, respc(77+15), tocolor(35, 35, 35))
		dxDrawRectangle(0, respc(77+15), screenX, respc(5), tocolor(61, 122, 188, 200))
		dxDrawImage(respc(5), respc(77+15)/2-respc(85)/2, respc(85), respc(85), exports.sm_core:getServerLogo())
		
	end

	if sideGuiState then
		local k = 1

		if testingInterior then
			k = drawSideIcon(k, "lighton", "lightoff", "day", daytimeMode, "Lámpák: " .. (daytimeMode and "felkapcsolva" or "lekapcsolva"))
			k = drawSideIcon(k, "testleave", "testleave", "test", true, "Teszt mód kikapcsolása")
		else
			k = drawSideIcon(k, "save", "save", "save:selectSound", false, "Mentés és kilépés")
			k = drawSideIcon(k, "lighton", "lightoff", "day", daytimeMode, "Lámpák: " .. (daytimeMode and "felkapcsolva" or "lekapcsolva"))
			k = drawSideIcon(k, "gridon", "gridoff", "grid:selectSound", gridVisible, "Vonalak: " .. (gridVisible and "bekapcsolva" or "kikapcsolva"))

			if selectedFurniture or activeMode == "placeFurniture" then
				if not snapMove then
					k = drawSideIcon(k, "snapoff", "snapoff", "snap:5:selectSound", false, "Mozgatási illesztés: kikapcsolva")
				elseif snapMove == 5 then
					k = drawSideIcon(k, "snap1", "snap1", "snap:10:selectSound", false, "Mozgatási illesztés: durva")
				else
					k = drawSideIcon(k, "snap2", "snap2", "snap:0:selectSound", false, "Mozgatási illesztés: finom")
				end

				if not snapRotation then
					k = drawSideIcon(k, "snapoffr", "snapoffr", "snapr:5:selectSound", false, "Forgatási illesztés: kikapcsolva")
				elseif snapRotation == 5 then
					k = drawSideIcon(k, "snap1r", "snap1r", "snapr:10:selectSound", false, "Forgatási illesztés: durva")
				else
					k = drawSideIcon(k, "snap2r", "snap2r", "snapr:0:selectSound", false, "Forgatási illesztés: finom")
				end
			end

			k = drawSideIcon(k, "test", "test", "test", false, "Teszt mód")
			k = drawSideIcon(k, "musicon", "musicoff", "music:selectSound", musicState, "Zene " .. (musicState and "ki" or "be"))
			k = drawSideIcon(k, "soundon", "soundoff", "sound:selectSound", soundState, "Hangok " .. (soundState and "ki" or "be"))
			k = drawSideIcon(k, "exit", "exit", "exit:selectSound", false, "Kilépés mentés nélkül")
		end
	end
end

function drawGUI()
	dxDrawImage(0, 0, screenX, screenY, "files/vin.png", 0, 0, 0, tocolor(0, 0, 0, 225))

	drawSideGUI()

	dxDrawRectangle(0, screenY - menuHeight, screenX, menuHeight, tocolor(25, 25, 25))
	dxDrawRectangle(0, screenY - menuHeight - navHeight, screenX, navHeight, tocolor(35, 35, 35))
	if showSmallesZero then
		theCurrentMoneyText = "Visszajár"
	else
		theCurrentMoneyText = "Költség"
	end
	if sideGuiState then
		dxDrawText(theCurrentMoneyText..": #3d7abc" .. cashCostsForDraw .. "$ #ffffff| Egyenleg: #3d7abc" .. currentBalance .. "$", 0, 0+respc(85)/2, screenX - respc(10), 0+respc(85)/2, tocolor(255, 255, 255), 1, Roboto, "right", "center", false, false, false, true)
	end 
	local x = respc(10)
	local y = screenY - menuHeight - navHeight

	x = drawIconText(x, y, "brick", "Falak", false, "walls")

	if activeMenu == "walls" then
		x = drawText(x, y, "Rajzolás", "drawing")
		x = drawText(x, y, "Festékek", "paint")
		x = drawText(x, y, "Tapéták", "wallpaper")
		x = drawText(x, y, "Csempék", "tile")
		x = drawText(x, y, "Plafon", "ceil", true)
	end

	x = drawIconText(x, y, "floor", "Burkolatok", true, "floors")

	if activeMenu == "floors" then
		x = drawText(x, y, "Fa padlók", "wood")
		x = drawText(x, y, "Csempék", "tile")
		x = drawText(x, y, "Padlószőnyegek", "carpet", true)
	end

	x = drawIconText(x, y, "door", "Nyílászárók", true, "doors")

	if activeMenu == "doors" then
		x = drawText(x, y, "Ajtók", "doors")
		x = drawText(x, y, "Ablakok", "windows", true)
	end

	x = drawIconText(x, y, "furniture", "Bútorok", true, "furnitures")

	if activeMenu == "furnitures" then
		for i = 1, #furnitureCategories do
			local k = furnitureCategories[i]

			x = drawText(x, y, k, k, i == #furnitureCategories)
		end
	end

	local item = 1

	if activeSubMenu == "ceil" then
		for i = 1 + menuOffset.ceil.normal, math.min(menuItemNum, #availableTextures.ceil.normal) + menuOffset.ceil.normal do
			item = drawItemRectangle(item, "textures/ceil/normal/" .. i, pricesForDraw.texture["ceil,normal," .. i] .. " $", "mode:setCeil:" .. i .. ":selectSound", activeMode == "setCeil" and selectedItem == tostring(i), true)
		end
	elseif activeMenu == "walls" then
		if activeSubMenu == "drawing" then
			item = drawItemRectangle(item, "images/drawline", "Vonal (" .. pricesForDraw.wall .. " $)", "mode:drawWall_line:selectSound", activeMode == "drawWall_line")
			item = drawItemRectangle(item, "images/drawrect", "Téglalap (" .. pricesForDraw.wall .. " $)", "mode:drawWall_rect:selectSound", activeMode == "drawWall_rect")
			--item = drawItemRectangle(item, "images/deleteline", "Vonal", "mode:deleteWall_line:selectSound", activeMode == "deleteWall_line")
			item = drawItemRectangle(item, "images/deleterect", "Téglalap", "mode:deleteWall_rect:selectSound", activeMode == "deleteWall_rect")
		else
			for i = 1 + menuOffset.wall[activeSubMenu], math.min(menuItemNum, #availableTextures.wall[activeSubMenu]) + menuOffset.wall[activeSubMenu] do
				item = drawItemRectangle(item, "textures/wall/" .. activeSubMenu .. "/" .. i, pricesForDraw.texture["wall," .. activeSubMenu .. "," .. i] .. " $", "mode:setWallpaper:" .. activeSubMenu .. "/" .. i .. ":selectSound", activeMode == "setWallpaper" and selectedItem == activeSubMenu .. "/" .. i, true)
			end
		end
	elseif activeMenu == "floors" then
		for i = 1 + menuOffset.floor[activeSubMenu], math.min(menuItemNum, #availableTextures.floor[activeSubMenu]) + menuOffset.floor[activeSubMenu] do
			item = drawItemRectangle(item, "textures/floor/" .. activeSubMenu .. "/" .. i, pricesForDraw.texture["floor," .. activeSubMenu .. "," .. i] .. " $", "mode:setFloor:" .. activeSubMenu .. "/" .. i .. ":selectSound", activeMode == "setFloor" and selectedItem == activeSubMenu .. "/" .. i, true)
		end
	elseif activeSubMenu == "windows" then
		local k = menuOffset.window.normal

		if k == 0 then
			item = drawItemRectangle(item, "images/deletewindow", "Törlés", "mode:deleteWindow:selectSound", activeMode == "deleteWindow")
		else
			k = k - 1
		end

		for i = 1 + k, math.min(menuItemNum, #availableTextures.window.normal) + k do
			item = drawItemRectangle(item, "textures/window/normal/" .. i, pricesForDraw.window .. " $", "mode:setWindow:" .. i .. ":selectSound", activeMode == "setWindow" and tonumber(selectedItem) == i, true, true)
		end
	elseif activeSubMenu == "doors" then
		local k = menuOffset.door["1"]

		if k == 0 then
			item = drawItemRectangle(item, "images/deletedoor", "Törlés", "mode:deleteDoor:selectSound", activeMode == "deleteDoor")
		else
			k = k - 1
		end

		local typeNum = 1
		local textureNum = -1 + k

		if k >= 1 then
			while true do
				if #availableTextures.door[tostring(typeNum)] < textureNum then
					textureNum = textureNum - #availableTextures.door[tostring(typeNum)] - 1
					typeNum = typeNum + 1
				else
					break
				end
			end
		end

		for i = 1, menuItemNum do
			textureNum = textureNum + 1

			if #availableTextures.door[tostring(typeNum)] < textureNum then
				textureNum = 0
				typeNum = typeNum + 1
			end

			item = drawItemRectangle(item, "textures/door/" .. typeNum .. "/" .. textureNum, pricesForDraw.door[typeNum] .. " $", "mode:setDoor:" .. typeNum .. "/" .. textureNum .. ":selectSound", activeMode == "setDoor" and selectedItem == typeNum .. "/" .. textureNum, true, "door")
		end
	elseif activeMenu == "furnitures" then
		for i = 1 + menuOffset.furnitures[activeSubMenu], math.min(menuItemNum, #availableFurnitures[activeSubMenu]) + menuOffset.furnitures[activeSubMenu] do
			local k = availableFurnitures[activeSubMenu][i]
			
			if k then
				local price = ""
				local stock = false

				if k == 2332 or k == 2964 or useableTvs[k] then
					price = "#32b3ef" .. pricesForDraw.furnitures[k] .. " PP"

					if useableTvs[k] then
						stock = (ppThings[k] or 0) - (ppFurnitures[k] or 0) .. " db"
					end
				else
					price = pricesForDraw.furnitures[k] .. " $"
				end

				item = drawItemRectangle(item, "images/furnitures/" .. k, price, "mode:placeFurniture:" .. k .. ":selectSound", activeMode == "placeFurniture" and getElementModel(activeFurniture) == k, false, false, stock)
			end
		end
	end

	if activePrompt then
		local sx = respc(600)
		local sy = respc(100)
		local x = (screenX - sx) / 2
		local y = (screenY - sy) / 2

		dxDrawRectangle(x, y, sx, sy, tocolor(25, 25, 25))
		--dxDrawText(activePrompt[2], x, y-sy/2, x + sx, y+sy/2, tocolor(255, 255, 255), 0.85, Roboto, "center", "center", false, false, false, true)
		dxDrawText(activePrompt[2], x+sx/2,y+respc(30)/2,x+sx/2,y+respc(30)/2, tocolor(200, 200, 200, 200), 0.85, Roboto, "center", "center", false, false, false, true)
		if exports.sm_core:isInSlot(x+respc(4), y + sy-respc(54), sx / 2-respc(8), respc(50)) then
			exports.sm_hud:dxDrawRoundedRectangle(x+respc(4), y + sy-respc(54), sx / 2-respc(8), respc(50), tocolor(61, 122, 188, 200))
			activeButton = "promptYes"
		else
			exports.sm_hud:dxDrawRoundedRectangle(x+respc(4), y + sy-respc(54), sx / 2-respc(8), respc(50), tocolor(61, 122, 188, 150))
		end

		dxDrawText("Igen", x, y + sy-respc(54), x + sx / 2, y + sy + respc(50)-respc(54), tocolor(200, 200, 200, 200), 1, RobotoL, "center", "center")

		if exports.sm_core:isInSlot(x+respc(4) + sx / 2, y + sy-respc(54), sx / 2-respc(8), respc(50)) then
			exports.sm_hud:dxDrawRoundedRectangle(x+respc(4) + sx / 2, y + sy-respc(54), sx / 2-respc(8), respc(50), tocolor(215, 89, 89, 200))
			activeButton = "promptNo"
		else
			exports.sm_hud:dxDrawRoundedRectangle(x+respc(4) + sx / 2, y + sy-respc(54), sx / 2-respc(8), respc(50), tocolor(215, 89, 89, 150))
		end

		dxDrawText("Nem", x + sx / 2, y + sy-respc(54), x + sx, y + sy + respc(50)-respc(54), tocolor(200, 200, 200, 200), 1, RobotoL, "center", "center")
	end
end

function coordToLineTile(x, line)
	x = x * 2

	if line == 3 or line == 4 then
		x = x + 1
	end

	return x
end

function lineTileToCoord(x, axis)
	local line = x % 2

	if axis == "x" then
		if line == 1 then
			line = 3
		else
			line = 1
		end
	elseif axis == "y" then
		if line == 1 then
			line = 4
		else
			line = 2
		end
	end

	x = math.floor(x / 2)

	return x, line
end

function loopLineTiles(loopFunction)
	if activeTileX == selectedTileX and activeTileY == selectedTileY and activeTileLine == selectedTileLine then
		loopFunction(activeTileX, activeTileX)
	else
		local startCoord = selectedTileX
		local endCoord = activeTileX

		if selectedTileAxis == "y" then
			startCoord = selectedTileY
			endCoord = activeTileY
		end

		startCoord = coordToLineTile(startCoord, selectedTileLine)
		endCoord = coordToLineTile(endCoord, activeTileLine)

		local startTile = math.min(startCoord, endCoord)
		local endTile = math.max(startCoord, endCoord)

		loopFunction(startTile, endTile)
	end
end

function coordToTile(x, y, line)
	x = x * 2
	y = y * 2

	if line == 4 or line == 5 then
		x = x + 1
	end

	if line == 6 or line == 5 then
		y = y + 1
	end

	return x, y
end

function tileToCoord(x, y)
	local x2 = x % 2
	local y2 = y % 2
	local line = 3

	if x2 == 1 and y2 == 1 then
		line = 5
	elseif x2 == 1 then
		line = 4
	elseif y2 == 1 then
		line = 6
	end

	x = math.floor(x / 2)
	y = math.floor(y / 2)

	return x, y, line
end

function loopTiles(loopFunction)
	if activeTileX == selectedTileX and activeTileY == selectedTileY and activeTileLine == selectedTileLine then
		loopFunction(activeTileX, activeTileY, activeTileLine)
	else
		local startCoordX, startCoordY = coordToTile(selectedTileX, selectedTileY, selectedTileLine)
		local endCoordX, endCoordY = coordToTile(activeTileX, activeTileY, activeTileLine)
		
		local minX = math.min(startCoordX, endCoordX)
		local maxX = math.max(startCoordX, endCoordX)
		local minY = math.min(startCoordY, endCoordY)
		local maxY = math.max(startCoordY, endCoordY)

		for x = minX, maxX do
			for y = minY, maxY do
				loopFunction(tileToCoord(x, y))
			end
		end
	end
end

function activizeTile(x, y, line)
	activeTiles[x .. "," .. y .. "," .. line] = true
end

function activizeTiles(min, max)
	if min == max then
		activizeTile(selectedTileX, selectedTileY, selectedTileLine)

		if activeTileX ~= lastActiveTileX or activeTileY ~= lastActiveTileY then
			playSoundEx("files/sounds/greenline.mp3")
			lastActiveTileX = activeTileX
			lastActiveTileY = activeTileY
		end
	else
		if min ~= lastActiveTileX or max ~= lastActiveTileY then
			playSoundEx("files/sounds/greenline.mp3")
			lastActiveTileX = min
			lastActiveTileY = max
		end

		for i = min, max do
			local coord, line = lineTileToCoord(i, selectedTileAxis)

			if selectedTileAxis == "x" then
				activizeTile(coord, selectedTileY, line)
			else
				activizeTile(selectedTileX, coord, line)
			end
		end
	end
end

function deleteWall(x, y)
	local obj = wallObjects[x .. "," .. y]

	if obj then
		local model = getElementModel(obj)

		removeAllTexturesFromElement(obj)

		for i = 1, #walls do
			if walls[i] == obj then
				table.remove(walls, i)
				break
			end
		end

		wallPositions[obj] = nil
		destroyElement(obj)
		wallObjects[x .. "," .. y] = nil

		local multipler = 1

		if model == editorModels.straight then
			multipler = 2
		elseif model == editorModels.two then
			multipler = 2
		elseif model == editorModels.three then
			multipler = 3
		elseif model == editorModels.four then
			multipler = 4
		end

		addCashCosts(-prices.wall * multipler)
	end

	local obj = doorObjects[x .. "," .. y]

	if obj then
		doorPositions[obj] = nil
		deleteDoor(obj)
		destroyElement(obj)
		doorObjects[x .. "," .. y] = nil
	end
end

function makeCorner(x, y, angle)
	local obj = wallObjects[x .. "," .. y]

	if obj then
		local model = getElementModel(obj)

		if model == editorModels.three then
			setElementModelEx(obj, editorModels.four)
			setElementRotation(obj, 0, 0, 0)
		elseif model == editorModels.two then
			local rz = select(3, getElementRotation(obj))
			local diff = rz - angle

			setElementModelEx(obj, editorModels.three)

			if diff == 90 or diff == -270 then
				setElementRotation(obj, 0, 0, rz)
			elseif diff == -90 or diff == 270 then
				setElementRotation(obj, 0, 0, rz + 90)
			end
		else
			setElementModelEx(obj, editorModels.two)
			setElementRotation(obj, 0, 0, angle)
		end
	end
end

function createWall(x, y, angle, half, model, corner)
	local obj = wallObjects[x .. "," .. y]

	if not obj then
		local modelType = "straight"

		if half then
			modelType = "half"
		end
		
		obj = createObject(model or editorModels[modelType], editorX + (x - 0.5) * oneTileSize, editorY + (y - 0.5) * oneTileSize, editorZ + 1.75, 0, 0, angle)

		if isElement(obj) then
			setElementInteriorAndDimension(obj, 1)
				
			wallPositions[obj] = {x, y}
			wallObjects[x .. "," .. y] = obj

			table.insert(walls, obj)

			if not model and not corner then
				if half then
					addCashCosts(prices.wall, true)
				else
					addCashCosts(prices.wall * 2, true)
				end
			end

			if corner then
				addCashCosts(prices.wall * 2, true)
			end

			return obj
		end
	elseif half then
		local rz = select(3, getElementRotation(obj))
		local diff = angle - rz

		if diff < 0 then
			diff = diff + 360
		end

		if getElementModel(obj) == editorModels.half then
			if math.abs(diff) ~= 0 then -- ha van eltérés a két fal forgása között
				if math.abs(diff) == 180 then -- 2 fél falból 1 teljes fal
					setElementModelEx(obj, editorModels.straight)

					if angle == 90 or angle == 270 then
						setElementRotation(obj, 0, 0, 90)
					else
						setElementRotation(obj, 0, 0, 0)
					end
				else -- 2 különböző tengelyen lévő fél falból 1 teljes "sarok" fal
					setElementModelEx(obj, editorModels.two)

					if diff == 90 then -- ha 90 fokos az eltérés
						setElementRotation(obj, 0, 0, rz + 180)
					else
						setElementRotation(obj, 0, 0, rz + 90)
					end
				end

				addCashCosts(prices.wall, true)
			end
		elseif getElementModel(obj) == editorModels.two then -- 1 "sarok" falból 3-as fal (T alak)
			if diff ~= -90 and diff ~= -180 and diff ~= 180 and diff ~= 270 then
				setElementModelEx(obj, editorModels.three)

				if diff ~= 90 then
					setElementRotation(obj, 0, 0, rz + 90)
				else
					setElementRotation(obj, 0, 0, rz)
				end

				addCashCosts(prices.wall, true)
			end
		elseif getElementModel(obj) == editorModels.straight then -- 1 teljes falból 3-as fal (T alak)
			setElementModelEx(obj, editorModels.three)

			if diff == -270 then
				setElementRotation(obj, 0, 0, rz)
			elseif diff == -90 then
				setElementRotation(obj, 0, 0, rz + 90)
			elseif diff == 90 then
				setElementRotation(obj, 0, 0, rz + 270)
			elseif diff == 270 then
				setElementRotation(obj, 0, 0, rz + 90)
			end

			addCashCosts(prices.wall, true)
		elseif getElementModel(obj) == editorModels.three and diff == 0 then -- 3-as (T alak) falból egy 4-es (+) fal
			setElementModelEx(obj, editorModels.four)
			setElementRotation(obj, 0, 0, 0)
			addCashCosts(prices.wall, true)
		end
	else
		local rz = select(3, getElementRotation(obj))
		local diff = angle - rz

		if diff < 0 then
			diff = diff + 360
		end

		if getElementModel(obj) == editorModels.straight and (math.abs(diff) == 90 or math.abs(diff) == 270) then
			setElementModelEx(obj, editorModels.four)
			setElementRotation(obj, 0, 0, 0)

			if not corner then
				addCashCosts(prices.wall * 2, true)
			end
		elseif getElementModel(obj) == editorModels.half then
			setElementModelEx(obj, editorModels.three)
			setElementRotation(obj, 0, 0, rz + 180)
			addCashCosts(prices.wall * 2, true)
		end
	end
end

function placeLineWalls(x, y)
	if x == y then
		if selectedTileLine == 1 then
			createWall(selectedTileX, selectedTileY, 90, true)
		elseif selectedTileLine == 2 then
			createWall(selectedTileX, selectedTileY, 180, true)
		elseif selectedTileLine == 3 then
			createWall(selectedTileX, selectedTileY, 270, true)
		elseif selectedTileLine == 4 then
			createWall(selectedTileX, selectedTileY, 0, true)
		end

		playSoundEx("files/sounds/construct" .. math.random(2) .. ".mp3")
	else
		local coordX, lineX = lineTileToCoord(x, selectedTileAxis)
		local coordY, lineY = lineTileToCoord(y, selectedTileAxis)

		if lineX == 3 or lineX == 4 then
			x = x + 1

			if selectedTileAxis == "x" then
				createWall(coordX, selectedTileY, 270, true)
			else
				createWall(selectedTileX, coordX, 0, true)
			end
		end

		if lineY == 1 or lineY == 2 then
			y = y - 1

			if selectedTileAxis == "x" then
				createWall(coordY, selectedTileY, 90, true)
			else
				createWall(selectedTileX, coordY, 180, true)
			end
		end

		for i = x / 2, y / 2 do
			if selectedTileAxis == "x" then
				createWall(i, selectedTileY, 90)
			else
				createWall(selectedTileX, i, 0)
			end
		end

		playSoundEx("files/sounds/construct" .. math.random(2) .. ".mp3")
	end
end

function setElementModelEx(element, model)
	if getElementModel(element) ~= model then
		setElementModel(element, model)
		removeAllTexturesFromElement(element)
		return true
	else
		return false
	end
end

function getShaderForTexture(path, category, name, id)
	if not textureUses[path] then
		textureUses[path] = 0
	end

	textureUses[path] = textureUses[path] + 1

	if not textureShaders[path] then
		textureShaders[path] = dxCreateShader("files/texturechanger.fx", 1, 0, true, "object")
		dxSetShaderValue(textureShaders[path], "gTexture", availableTextures[category][name][id])
	end

	return textureShaders[path]
end

function applyTextureToElement(element, texture, category, name, id, firstLoad, soundEffect)
	id = tonumber(id)

	if not textureShaders[element] then
		textureShaders[element] = {}
	end

	if not texturePaths[element] then
		texturePaths[element] = {}
	end

	local path = table.concat({category, name, id}, ",")

	if texturePaths[element][texture] ~= path  then
		local shader = getShaderForTexture(path, category, name, id)

		if textureShaders[element][texture] ~= shader then
			if textureShaders[element][texture] then
				engineRemoveShaderFromWorldTexture(textureShaders[element][texture], texture, element)
				removeTexture(texturePaths[element][texture])
			end

			if prices.texture[path] and not firstLoad then
				addCashCosts(prices.texture[path], category == "floor" or category == "ceil" or soundEffect)
			end

			engineApplyShaderToWorldTexture(shader, texture, element)

			textureShaders[element][texture] = shader
			texturePaths[element][texture] = path
		end
	end
end

function removeTexture(path)
	if not textureUses[path] then
		textureUses[path] = 0
	end

	textureUses[path] = textureUses[path] - 1

	if prices.texture[path] then
		addCashCosts(-prices.texture[path])
	end

	if textureUses[path] <= 0 then
		textureUses[path] = nil
		destroyElement(textureShaders[path])
		textureShaders[path] = nil
	end
end

function removeTextureFromElement(element, texture)
	if not textureShaders[element] then
		textureShaders[element] = {}
	end

	if not texturePaths[element] then
		texturePaths[element] = {}
	end

	if textureShaders[element][texture] and texturePaths[element][texture] then
		engineRemoveShaderFromWorldTexture(textureShaders[element][texture], texture, element)
		removeTexture(texturePaths[element][texture])

		textureShaders[element][texture] = nil
		texturePaths[element][texture] = nil
	end
end

function removeAllTexturesFromElement(element)
	if textureShaders[element] then
		for texture in pairs(textureShaders[element]) do
			engineRemoveShaderFromWorldTexture(textureShaders[element][texture], texture, element)
		end
	end

	if texturePaths[element] then
		for _, path in pairs(texturePaths[element]) do
			removeTexture(path)
		end
	end

	texturePaths[element] = {}
	textureShaders[element] = {}
end

function setWallpaper()
	local hitElement, hitX, hitY = unpack(hoverWallData)
	local model = getElementModel(hitElement)

	local x, y = getElementPosition(hitElement)
	local rz = select(3, getElementRotation(hitElement))

	local angle = math.atan2(hitY - y, hitX - x)
	local category, id = unpack(split(selectedItem, "/"))

	if model == editorModels.base then
		if rz == 0 then
			if angle < 0 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			end
		elseif rz == 90 then
			if angle < -2 then
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			end
		elseif rz == 180 then
			if angle < 0 then
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			end
		elseif rz == 270 then
			if angle < 1 then
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			end
		end
	elseif model == editorModels.two then
		if rz == 0 then
			if angle < 0 and angle >= -1 then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			elseif angle < -1 and angle > -1.6 then
				applyTextureToElement(hitElement, "tile_4", "wall", category, id)
			elseif angle > 0 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			end
		elseif rz == 90 then
			if angle > 0 and angle <= 0.5 then
				applyTextureToElement(hitElement, "tile_4", "wall", category, id)
			elseif angle > 0.5 and angle < 1.6 then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			elseif angle > 0 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			end
		elseif rz == 180 then
			if angle > 1.6 and angle <= 2.3 then
				applyTextureToElement(hitElement, "tile_4", "wall", category, id)
			elseif angle > 2.3 and angle < 3.1 then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			elseif angle < -0.8 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			end
		elseif rz == 270 then
			if angle < -1.6 and angle >= -2.3 then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			elseif angle < -2.3 and angle > -3.1 then
				applyTextureToElement(hitElement, "tile_4", "wall", category, id)
			elseif angle > 0.7 then
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			end
		end
	elseif model == editorModels.four then
		if angle > -3.1 and angle <= -2.4 then
			applyTextureToElement(hitElement, "tile_6", "wall", category, id)
		elseif angle > -2.4 and angle <= -1.6 then
			applyTextureToElement(hitElement, "tile_7", "wall", category, id)
		elseif angle > -1.6 and angle <= -0.9 then
			applyTextureToElement(hitElement, "tile_2", "wall", category, id)
		elseif angle > -0.9 and angle <= 0 then
			applyTextureToElement(hitElement, "tile_1", "wall", category, id)
		elseif angle > 0 and angle <= 0.7 then
			applyTextureToElement(hitElement, "tile_4", "wall", category, id)
		elseif angle > 0.7 and angle <= 1.6 then
			applyTextureToElement(hitElement, "tile_8", "wall", category, id)
		elseif angle > 1.6 and angle <= 2.3 then
			applyTextureToElement(hitElement, "tile_3", "wall", category, id)
		else
			applyTextureToElement(hitElement, "tile_5", "wall", category, id)
		end
	elseif model == editorModels.three then
		if rz == 0 then
			if angle > -3.1 and angle <= -2.4 then
				applyTextureToElement(hitElement, "tile_4", "wall", category, id)
			elseif angle > -2.4 and angle <= -1.6 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			elseif angle > -1.6 and angle <= -1 then
				applyTextureToElement(hitElement, "tile_5", "wall", category, id)
			elseif angle > -1 and angle <= 0 then
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			elseif angle > 1.6 then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_6", "wall", category, id)
			end
		elseif rz == 90 then
			if angle > -1.6 and angle <= -1 then
				applyTextureToElement(hitElement, "tile_4", "wall", category, id)
			elseif angle > -1 and angle <= 0 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			elseif angle > 0 and angle <= 0.6 then
				applyTextureToElement(hitElement, "tile_5", "wall", category, id)
			elseif angle > 0.6 and angle <= 1.6 then
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			elseif angle < 0 then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_6", "wall", category, id)
			end
		elseif rz == 180 then
			if angle > 0 and angle <= 0.7 then
				applyTextureToElement(hitElement, "tile_4", "wall", category, id)
			elseif angle > 0.7 and angle <= 1.6 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			elseif angle > 1.6 and angle <= 2.1 then
				applyTextureToElement(hitElement, "tile_5", "wall", category, id)
			elseif angle > 2.1 and angle <= 3.1 then
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			elseif angle > -1.6 then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_6", "wall", category, id)
			end
		elseif rz == 270 then
			if angle > -3.1 and angle <= -2.4 then
				applyTextureToElement(hitElement, "tile_5", "wall", category, id)
			elseif angle > -2.4 and angle <= -1.6 then
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			elseif angle > 1.6 and angle <= 2.4 then
				applyTextureToElement(hitElement, "tile_4", "wall", category, id)
			elseif angle > 2.4 and angle <= 3.1 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			elseif angle > 0 then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_6", "wall", category, id)
			end
		end
	elseif model == editorModels.straight then
		if rz == 90 then
			if angle > -3.1 and angle <= -1.6 then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			elseif angle > -1.6 and angle < 0 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			elseif angle < 1.5 then
				applyTextureToElement(hitElement, "tile_4", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_3", "wall", category, id)
			end
		elseif angle > 1.6 and angle <= 3.1 then
			applyTextureToElement(hitElement, "tile_1", "wall", category, id)
		elseif angle > -3.1 and angle < -1.6 then
			applyTextureToElement(hitElement, "tile_2", "wall", category, id)
		elseif angle > -1.6 and angle < 0 then
			applyTextureToElement(hitElement, "tile_4", "wall", category, id)
		elseif angle > 0 and angle < 1.6 then
			applyTextureToElement(hitElement, "tile_3", "wall", category, id)
		end
	elseif model == editorModels.half then
		if rz == 0 then
			if angle > 1.6 then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			end
		elseif rz == 90 then
			if angle < 0 then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			end
		elseif rz == 180 then
			if angle < -1.6 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			end
		elseif rz == 270 then
			if angle < 0 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			else
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			end
		end
	elseif model == editorModels.door or model == editorModels.door2 then
		if rz == 0 then
			if angle < 1.6 and angle > -1.6 then
				if currentBaseDoor[2] ~= hitElement then
					applyTextureToElement(hitElement, "tile_1", "wall", category, id)
				end
			else
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			end
		elseif rz == 90 then
			if angle > 0 then
				if currentBaseDoor[2] ~= hitElement then
					applyTextureToElement(hitElement, "tile_1", "wall", category, id)
				end
			else
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			end
		elseif rz == 180 then
			if angle < -1.6 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			elseif currentBaseDoor[2] ~= hitElement then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			end
		elseif rz == 270 then
			if angle > 0 then
				applyTextureToElement(hitElement, "tile_2", "wall", category, id)
			elseif currentBaseDoor[2] ~= hitElement then
				applyTextureToElement(hitElement, "tile_1", "wall", category, id)
			end
		end
	end
end

function applyFloorTexture(x, y, line)
	if line == 3 then
		line = 2
	elseif line == 4 then
		line = 3
	elseif line == 5 then
		line = 4
	elseif line == 6 then
		line = 1
	end

	applyTextureToElement(floorObjects[x .. "," .. y], "tile_" .. line, "floor", unpack(split(selectedItem, "/")))
end

function applyCeilTexture(x, y, line)
	if line == 3 then
		line = 2
	elseif line == 4 then
		line = 1
	elseif line == 5 then
		line = 4
	elseif line == 6 then
		line = 3
	end

	applyTextureToElement(ceilObjects[x .. "," .. y], "tile_" .. line, "ceil", "normal", tonumber(selectedItem))
end

function createBaseDoor(data, firstLoad, restore)
	if currentBaseDoor and not currentBaseDoor[7] then
		local textures = {}
		local obj = currentBaseDoor[2]

		if texturePaths[obj] then
			if texturePaths[obj]["tile_1"] then
				textures[1] = texturePaths[obj]["tile_1"]
			end

			if texturePaths[obj]["tile_2"] then
				textures[2] = texturePaths[obj]["tile_2"]
			end
		end

		removeTextureFromElement(currentBaseDoor[2], "tile_1")
		removeTextureFromElement(currentBaseDoor[2], "tile_2")

		currentBaseDoor[7] = textures
	end

	deleteBaseDoor()

	if data then
		local angle = data[4]
		local model = data[5]

		local offsetX, offsetY, offsetZ = -0.025, 0.785, -1.765

		if angle > 0 then
			offsetX, offsetY = 0.025, -0.75
		end

		if not restore then
			if currentBaseDoor and data[2] == currentBaseDoor[2] then
				if currentBaseDoor[7][1] then
					local texture = split(currentBaseDoor[7][1], ",")

					applyTextureToElement(data[2], "tile_1", "wall", texture[2], tonumber(texture[3]))
				end

				if currentBaseDoor[7][2] then
					local texture = split(currentBaseDoor[7][2], ",")

					applyTextureToElement(data[2], "tile_2", "wall", texture[2], tonumber(texture[3]))
				end
			else
				removeTextureFromElement(data[2], "tile_1")
				removeTextureFromElement(data[2], "tile_2")
			end
		end

		setElementModel(data[2], editorModels.door2)

		local x, y, z = getPositionFromMatrixOffset(getElementMatrix(data[2]), offsetX, offsetY, offsetZ)
		local rz = select(3, getElementRotation(data[2]))
		local obj = createObject(model, x, y, z, 0, 0, rz + angle)

		data[1] = obj
		doorRotations[obj] = angle

		setElementInteriorAndDimension(obj, 1)
		setElementCollisionsEnabled(obj, false)

		if model == 1491 then
			setObjectScale(obj, 1.005)
		end

		if not editingInterior then
			local x, y = getElementPosition(data[2])

			baseDoorColShape = createColRectangle(x - oneTileSize / 2, y - oneTileSize / 2, oneTileSize, oneTileSize)
		end

		local texture = tonumber(data[3])

		if texture > 0 then
			applyTextureToElement(obj, doorTextureNames[model], "door", doorModelIds[model], texture)
		end

		if not firstLoad then
			addCashCosts(prices.door[tonumber(doorModelIds[model])], true)
		end

		placedBaseDoor = data

		return data[2]
	end
end

function deleteBaseDoor()
	if placedBaseDoor then
		destroyElement(placedBaseDoor[1])

		if currentBaseDoor then
			destroyElement(currentBaseDoor[1])
		end

		setElementRotation(placedBaseDoor[2], 0, 0, placedBaseDoor[6])
		setElementModel(placedBaseDoor[2], editorModels.base)

		addCashCosts(-prices.door[tonumber(doorModelIds[placedBaseDoor[5]])])
	end

	placedBaseDoor = false
end

function setCurrentBaseDoor()
	currentBaseDoor = placedBaseDoor

	local currentX, currentY = exports.sm_interiors:getInteriorExitPosition(activeInteriorId)
	
	local doorX, doorY, doorZ = getElementPosition(currentBaseDoor[2])
	local doorRot = select(3, getElementRotation(currentBaseDoor[2]))
	
	local rotatedX, rotatedY = rotateAround(math.rad(doorRot), 0, 0, -oneTileSize / 2, 0)

	doorX = doorX + rotatedX
	doorY = doorY + rotatedY

	if math.floor(currentX * 10) / 10 ~= math.floor(doorX * 10) / 10 or math.floor(currentY * 10) / 10 ~= math.floor(doorY * 10) / 10 then
		exports.sm_interiors:setInteriorExitPosition(activeInteriorId, doorX, doorY, doorZ - 0.75 + oneTileWidth / 2 + 0.05, doorRot)

		if not editingInterior then
			setElementPosition(localPlayer, doorX, doorY, doorZ - 0.75)
		end
	end
end

function unuseDoorHover(lastWallHit)
	if activeMode == "deleteDoor" then
		if placedDoor and activeHitData then
			createDoor(unpack(placedDoor))

			local dat = split(activeHitData, ",")

			if tonumber(dat[3]) then
				applyTextureToElement(oldHitElement, "tile_1", "wall", dat[2], tonumber(dat[3]), false, true)
			end

			if tonumber(dat[6]) then
				applyTextureToElement(oldHitElement, "tile_2", "wall", dat[5], tonumber(dat[6]), false, true)
			end

			if tonumber(dat[9]) then
				applyTextureToElement(oldHitElement, "tile_3", "wall", dat[8], tonumber(dat[9]), false, true)
			end

			if tonumber(dat[12]) then
				applyTextureToElement(oldHitElement, "tile_4", "wall", dat[11], tonumber(dat[12]), false, true)
			end

			setElementModel(oldHitElement, editorModels.door2)
		end
	elseif baseWallPositions[oldHitElement] then
		if currentBaseDoor and placedBaseDoor[2] ~= currentBaseDoor[2] then
			setElementRotation(oldHitElement, 0, 0, activeHitData[1])
			setElementModel(oldHitElement, editorModels.base)

			if activeHitData[2][1] then
				local dat = split(activeHitData[2][1], ",")

				applyTextureToElement(oldHitElement, "tile_1", "wall", dat[2], tonumber(dat[3]), false, true)
			end

			if activeHitData[2][2] then
				local dat = split(activeHitData[2][2], ",")

				applyTextureToElement(oldHitElement, "tile_2", "wall", dat[2], tonumber(dat[3]), false, true)
			end
		end

		if (not lastWallHit or not baseWallPositions[lastWallHit]) and currentBaseDoor then
			local obj = createBaseDoor(currentBaseDoor, false, true)

			if currentBaseDoor[7][1] then
				local dat = split(currentBaseDoor[7][1], ",")

				applyTextureToElement(obj, "tile_1", "wall", dat[2], tonumber(dat[3]), false, true)
			end

			if currentBaseDoor[7][2] then
				local dat = split(currentBaseDoor[7][2], ",")

				applyTextureToElement(obj, "tile_2", "wall", dat[2], tonumber(dat[3]), false, true)
			end

			currentBaseDoor[7] = false
		end
	elseif oldHitElement and wallPositions[oldHitElement] then
		local x, y = unpack(wallPositions[oldHitElement])
		local obj = doorObjects[x .. "," .. y]

		if placedDoor then
			if obj then
				doorPositions[obj] = nil
				deleteDoor(obj)
				destroyElement(obj)
				doorObjects[x .. "," .. y] = nil
			end

			createDoor(unpack(placedDoor))
		elseif activeHitData then
			if obj then
				doorPositions[obj] = nil
				deleteDoor(obj)
				destroyElement(obj)
				doorObjects[x .. "," .. y] = nil
			end

			local dat = split(activeHitData, ",")

			if tonumber(dat[3]) then
				applyTextureToElement(oldHitElement, "tile_1", "wall", dat[2], tonumber(dat[3]), false, true)
			end

			if tonumber(dat[6]) then
				applyTextureToElement(oldHitElement, "tile_2", "wall", dat[5], tonumber(dat[6]), false, true)
			end

			if tonumber(dat[9]) then
				applyTextureToElement(oldHitElement, "tile_3", "wall", dat[8], tonumber(dat[9]), false, true)
			end

			if tonumber(dat[12]) then
				applyTextureToElement(oldHitElement, "tile_4", "wall", dat[11], tonumber(dat[12]), false, true)
			end

			setElementModel(oldHitElement, editorModels.straight)
		end
	elseif wallPositions[oldHitElement] then
		local x, y = unpack(wallPositions[oldHitElement])
		local obj = doorObjects[x .. "," .. y]

		if obj then
			doorPositions[obj] = nil
			deleteDoor(obj)
			destroyElement(obj)
			doorObjects[x .. "," .. y] = nil
		end
	end

	oldHitElement = false
	activeHitData = false
	hoverElemData = false
	placedDoor = false
end

function createDoor(x, y, model, angle, texture, firstLoad)
	local tile = x .. "," .. y
	local wall = wallObjects[tile]

	if not firstLoad then
		setElementModel(wall, editorModels.door2)
	end

	if not editingInterior then
		local x, y = getElementPosition(wall)
		local col = createColRectangle(x - oneTileSize / 2, y - oneTileSize / 2, oneTileSize, oneTileSize)

		doorColShape[tile] = col
		doorColPosition[col] = tile
	end

	local offsetX, offsetY, offsetZ = -0.025, 0.785, -1.765

	if angle > 0 then
		offsetX, offsetY = 0.025, -0.75
	end

	local x, y, z = getPositionFromMatrixOffset(getElementMatrix(wall), offsetX, offsetY, offsetZ)
	local rz = select(3, getElementRotation(wall))
	local obj = createObject(model, x, y, z, 0, 0, rz + angle)

	doorObjects[tile] = obj
	doorPositions[obj] = tile
	doorRotations[obj] = angle

	setElementInteriorAndDimension(obj, 1)
	setElementCollisionsEnabled(obj, false)

	if model == 1491 then
		setObjectScale(obj, 1.005)
	end

	if not firstLoad then
		addCashCosts(prices.door[tonumber(doorModelIds[model])], true)
	end

	texture = tonumber(texture)

	if texture > 0 then
		applyTextureToElement(obj, doorTextureNames[model], "door", doorModelIds[model], texture)
	end
end

function deleteDoor(element)
	if element then
		element = getElementModel(element)
		addCashCosts(-prices.door[tonumber(doorModelIds[element])])
	end
end

function createWindow(x, y, angle, texture, firstLoad)
	if not windowObjects[x .. "," .. y] then
		local obj = createObject(editorModels.window, editorX + (x / 2 - 0.5) * oneTileSize, editorY + (y / 2 - 0.5) * oneTileSize, editorZ + 1.75, 0, 0, angle)
		
		if isElement(obj) then
			windowPositions[obj] = {x, y}
			windowObjects[x .. "," .. y] = obj

			setElementInteriorAndDimension(obj, 1)
			setElementCollisionsEnabled(obj, false)

			applyTextureToElement(obj, "tile_1", "window", "normal", tonumber(texture))

			if not firstLoad then
				addCashCosts(prices.window, true)
			end
		end
	end
end

function destroyWindow(x, y)
	local obj = windowObjects[x .. "," .. y]

	if obj then
		destroyElement(obj)
		windowPositions[obj] = nil
		windowObjects[x .. "," .. y] = nil
		addCashCosts(-prices.window)
	end
end

function unuseWindowHover()
	if activeMode == "deleteWindow" then
		if hoverElemData then
			local x, y, angle = unpack(hoverElemData)
			local dat = split(activeHitData, ",")

			createWindow(x, y, angle, dat[3])
		end
	elseif oldHitElement and hoverElemData then
		local x, y = unpack(hoverElemData)

		if not activeHitData then
			destroyWindow(x, y)
		else
			local dat = split(activeHitData, ",")

			applyTextureToElement(windowObjects[x .. "," .. y], "tile_1", "window", "normal", dat[3])
		end
	end

	oldHitElement = false
	hoverElemData = false
	activeHitData = false
	oldWindowTile = false
end

function setActiveFurniture(element)
	if selectedFurniture ~= element then
		if element then
			canPlaceFurniture = false
			selectedFurniture = element
			setElementCollisionsEnabled(selectedFurniture, false)
		else
			if isElement(selectedFurniture) then
				local model = getElementModel(selectedFurniture)
				local x, y, z = getElementPosition(selectedFurniture)
				local rz = select(3, getElementRotation(selectedFurniture))

				if model == 2964 then
					local poolTableID = getElementData(selectedFurniture, "poolTableID")

					if poolTableID then
						triggerServerEvent("moveBilliardFurniture", localPlayer, poolTableID, x, y, z, rz)
					end
				elseif model == 2332 then
					local safeId = getElementData(selectedFurniture, "safeId")

					if safeId then
						triggerServerEvent("moveSafeFurniture", localPlayer, safeId, x, y, z, rz)
					end
				end

				setElementCollisionsEnabled(selectedFurniture, true)
			end

			selectedFurniture = false
		end

		floorMode(element)
	end
end

function moveFurniture(hitX, hitY, offsetX, offsetY, upDown)
	if getKeyState("mouse1") then
		local x, y, z = getElementPosition(selectedFurniture)
		local rz = select(3, getElementRotation(selectedFurniture))
	
		if furnitureRotateMode then
			if not movedFurniture then
				local model = getElementModel(selectedFurniture)
				local x2, y2 = x, y

				if boundingBox[model] then
					x2, y2 = rotateAround(math.rad(rz), 0, 0, boundingBox[model][7], boundingBox[model][8])
					x2, y2 = x + x2, y + y2
				end

				movedFurniture = {x2, y2, math.atan2(hitY - y2, hitX - x2) + math.rad(90) - math.rad(rz), rz, x, y}
			end

			if hitX ~= -1000 then
				local angle = math.atan2(hitY - movedFurniture[2], hitX - movedFurniture[1]) + math.rad(90) - movedFurniture[3]

				angle = math.deg(angle)

				if snapRotation then
					angle = math.ceil(angle / snapRotation) * snapRotation
				end

				setElementRotation(selectedFurniture, 0, 0, angle)

				if snapRotation then
					if math.floor(furnitureRotation) ~= angle and getTickCount() - rotateTick >= 175 then
						playSoundEx("files/sounds/rotate.mp3")
						rotateTick = getTickCount()
					end
				end

				furnitureRotation = angle

				x, y = rotateAround(math.rad(furnitureRotation) - math.rad(movedFurniture[4]), movedFurniture[1], movedFurniture[2], movedFurniture[5], movedFurniture[6])
				
				setElementPosition(selectedFurniture, x, y, z)
			end
		elseif upDown then
			if not movedFurniture then
				movedFurniture = {hitX - offsetX, hitY - offsetY, offsetX, offsetY, x, y, z, true}
				setCursorAlpha(0)
				cursorRelPos = {getCursorPosition()}
			end

			movedFurniture[9], movedFurniture[10] = offsetX, offsetY
		else
			if not movedFurniture then
				movedFurniture = {hitX, hitY, offsetX, offsetY, x, y, z, rz}
			end

			if hitX ~= -1000 then
				hitX = movedFurniture[5] + (hitX - movedFurniture[1]) * math.abs(movedFurniture[3])
				hitY = movedFurniture[6] + (hitY - movedFurniture[2]) * math.abs(movedFurniture[4])
				
				if snapMove then
					if movedFurniture[3] ~= 0 then
						hitX = math.floor(hitX * snapMove) / snapMove
					else
						hitY = math.floor(hitY * snapMove) / snapMove
					end
				end
				
				setElementPosition(selectedFurniture, hitX, hitY, movedFurniture[7])
			end
		end
	elseif movedFurniture then
		movedFurniture = false
	end
end

function setTest()
	selectedFurniture = false
	setMode("looking")

	testingInterior = not testingInterior
	playSoundEx("files/sounds/testmode.mp3")

	if testingInterior then
		destroyElement(bcgMusic)
		destroyElement(activeFurniture)
		activeFurniture = false

		showCursor(false)
		setCameraTarget(localPlayer)

		local x, y = cameraPivot[1], cameraPivot[2]

		if x < editorZone[1] + 1 then
			x = editorZone[1] + 1
		elseif x > editorZone[3] - 1 then
			x = editorZone[3] - 1
		end

		if y < editorZone[2] + 1 then
			y = editorZone[2] + 1
		elseif y > editorZone[4] - 1 then
			y = editorZone[4] - 1
		end

		setElementPosition(localPlayer, x, y, cameraPivot[3] + 0.5)
		setElementFrozen(localPlayer, false)
		setMode("test")
		showCeil(true)

		for k, v in pairs(doorObjects) do
			setElementCollisionsEnabled(v, true)
			setElementModel(wallObjects[k], editorModels.door)
		end
	else
		showCursor(true)
		setCameraMatrix(cameraPivot[4], cameraPivot[5], cameraPivot[6], cameraPivot[1], cameraPivot[2], cameraPivot[3])
		setElementPosition(localPlayer, 0, 0, 0)
		setElementFrozen(localPlayer, true)

		setMode("looking")
		showCeil(false)

		if musicState then
			startBcgMusic()
		end

		for k, v in pairs(doorObjects) do
			local rz = select(3, getElementRotation(wallObjects[k]))

			setElementCollisionsEnabled(v, false)
			setElementRotation(v, 0, 0, doorRotations[v] + rz)
			setElementModel(wallObjects[k], editorModels.door2)
		end
	end

	if cameraReversed then
		if testingInterior then
			showFloor(true)
		else
			showCeil(true)
			showFloor(false)
		end
	end
end

function toString(data)
	local str = ""

	-- ** Főfalak
	if data.baseWalls and #data.baseWalls > 0 then
		local temp = {}

		for i = 1, #data.baseWalls do
			table.insert(temp, data.baseWalls[i][1])
			table.insert(temp, data.baseWalls[i][2])
			table.insert(temp, data.baseWalls[i][3])
		end

		str = str .. table.concat(temp, "/")
	else
		str = str .. "-"
	end

	str = str .. ";"

	-- ** Padló
	if data.baseFloors and #data.baseFloors > 0 then
		local temp = {}

		for i = 1, #data.baseFloors do
			table.insert(temp, data.baseFloors[i][1])
			table.insert(temp, data.baseFloors[i][2])
			table.insert(temp, data.baseFloors[i][3])
		end

		str = str .. table.concat(temp, "/")
	else
		str = str .. "-"
	end

	str = str .. ";"

	-- ** Plafon
	if data.baseCeils and #data.baseCeils > 0 then
		local temp = {}

		for i = 1, #data.baseCeils do
			table.insert(temp, data.baseCeils[i][1])
			table.insert(temp, data.baseCeils[i][2])
			table.insert(temp, data.baseCeils[i][3])
		end

		str = str .. table.concat(temp, "/")
	else
		str = str .. "-"
	end

	str = str .. ";"

	-- ** Falak
	if data.walls and #data.walls > 0 then
		local temp = {}

		for i = 1, #data.walls do
			local dat = data.walls[i][1] .. "-"
			dat = dat .. data.walls[i][2] .. "-"
			dat = dat .. data.walls[i][3]

			if data.walls[i][4] then
				local textures = {}

				for k, v in pairs(data.walls[i][4]) do
					table.insert(textures, k)
					table.insert(textures, v)
				end

				dat = dat .. "-" .. table.concat(textures, "/")
			end

			table.insert(temp, dat)
		end

		str = str .. table.concat(temp, "|")
	else
		str = str .. "-"
	end

	str = str .. ";"

	-- ** Főajtó
	if data.baseDoor then
		local temp = {}

		table.insert(temp, table.concat(baseWallPositions[data.baseDoor[2]], ","))
		table.insert(temp, data.baseDoor[3])
		table.insert(temp, data.baseDoor[4])
		table.insert(temp, data.baseDoor[5])

		str = str .. table.concat(temp, "/")
	else
		str = str .. "-"
	end

	str = str .. ";"

	-- ** Ajtók
	if data.doors and #data.doors > 0 then
		local temp = {}

		for i = 1, #data.doors do
			table.insert(temp, data.doors[i][1])
			table.insert(temp, data.doors[i][2])
			table.insert(temp, data.doors[i][3])
			table.insert(temp, data.doors[i][4])
		end

		str = str .. table.concat(temp, "/")
	else
		str = str .. "-"
	end

	str = str .. ";"

	-- ** Ablakok
	if data.windows and #data.windows > 0 then
		local temp = {}

		for i = 1, #data.windows do
			table.insert(temp, data.windows[i][1])
			table.insert(temp, data.windows[i][2])
			table.insert(temp, data.windows[i][3])
		end

		str = str .. table.concat(temp, "/")
	else
		str = str .. "-"
	end

	str = str .. ";"

	-- ** Bútorok
	if data.furnitures and #data.furnitures > 0 then
		local temp = {}

		for i = 1, #data.furnitures do
			table.insert(temp, data.furnitures[i][1])
			table.insert(temp, data.furnitures[i][2])
			table.insert(temp, data.furnitures[i][3])
			table.insert(temp, data.furnitures[i][4])
			table.insert(temp, data.furnitures[i][5])
		end

		str = str .. table.concat(temp, "/")
	else
		str = str .. "-"
	end

	str = str .. ";"

	-- ** Költségek
	str = str .. data.costs

	return str
end

function fromString(str)
	local sections = split(str, ";")
	local data = {}

	-- ** Főfalak
	data.baseWalls = {}

	if sections[1] ~= "-" and sections[1] then
		local dat = split(sections[1], "/")

		for i = 1, #dat, 3 do
			table.insert(data.baseWalls, {dat[i], dat[i+1], dat[i+2]})
		end
	end

	-- ** Padló
	data.baseFloors = {}

	if sections[2] ~= "-" and sections[2] then
		local dat = split(sections[2], "/")

		for i = 1, #dat, 3 do
			table.insert(data.baseFloors, {dat[i], dat[i+1], dat[i+2]})
		end
	end

	-- ** Plafon
	data.baseCeils = {}

	if sections[3] ~= "-" and sections[3] then
		local dat = split(sections[3], "/")

		for i = 1, #dat, 3 do
			table.insert(data.baseCeils, {dat[i], dat[i+1], dat[i+2]})
		end
	end

	-- ** Falak
	data.walls = {}

	if sections[4] ~= "-" and sections[4] then
		local dat = split(sections[4], "|")

		for i = 1, #dat do
			local dat2 = split(dat[i], "-")

			if dat2[4] then
				local textures = split(dat2[4], "/")

				dat2[4] = {}

				for j = 1, #textures, 2 do
					dat2[4][textures[j]] = textures[j+1]
				end
			end

			table.insert(data.walls, dat2)
		end
	end

	-- ** Főajtó
	data.baseDoor = {}

	if sections[5] ~= "-" and sections[5] then
		local dat = split(sections[5], "/")

		data.baseDoor[2] = dat[1]
		data.baseDoor[3] = dat[2]
		data.baseDoor[4] = dat[3]
		data.baseDoor[5] = dat[4]
	end

	-- ** Ajtók
	data.doors = {}

	if sections[6] ~= "-" and sections[6] then
		local dat = split(sections[6], "/")

		for i = 1, #dat, 4 do
			table.insert(data.doors, {dat[i], dat[i+1], dat[i+2], dat[i+3]})
		end
	end

	-- ** Ablakok
	data.windows = {}

	if sections[7] ~= "-" and sections[7] then
		local dat = split(sections[7], "/")

		for i = 1, #dat, 3 do
			table.insert(data.windows, {dat[i], dat[i+1], dat[i+2]})
		end
	end

	-- ** Bútorok
	data.furnitures = {}

	if sections[8] ~= "-" and sections[8] then
		local dat = split(sections[8], "/")

		for i = 1, #dat, 5 do
			table.insert(data.furnitures, {dat[i], dat[i+1], dat[i+2], dat[i+3], dat[i+4], dat[i+5]})
		end
	end

	-- ** Költségek
	data.costs = tonumber(sections[9])

	return data
end

function addCashCosts(amount, firstLoad)
	cashCosts = cashCosts + amount
	if cashCosts - lastCashCosts < 0 then
		local theCost = tostring((cashCosts - lastCashCosts))
		
		cashCostsForDraw = formatNumber(utf8.gsub(theCost, "-", ""))
		showSmallesZero = true
	else
		cashCostsForDraw = formatNumber(cashCosts - lastCashCosts)
		showSmallesZero = false
	end
end

function updateDynamicData(data, force)
	if source ~= localPlayer or force then
		data = split(data, ";")

		if data[1] then
			if data[1] == "on" then
				daytimeMode = true
			else
				daytimeMode = false
			end

			setDaytime(daytimeMode)
		end

		if not doorStates then
			doorStates = {}
		end

		for k, v in pairs(doorStates) do
			if v ~= "inservice" then
				doorStates[k] = nil
			end
		end

		if not editingInterior then
			for k, v in pairs(doorObjects) do
				setElementCollisionsEnabled(v, true)
				setElementModel(wallObjects[k], editorModels.door)
			end
		end

		if data[2] then
			local dat = split(data[2], "|")

			for i = 1, #dat do
				local pos = dat[i]

				if pos ~= "-" then
					if utf8.sub(pos, 1, 1) == "d" then
						doorStates[utf8.sub(pos, 2)] = "damaged"
					elseif doorObjects[pos] then
						doorStates[pos] = true

						if not editingInterior then
							local rz = select(3, getElementRotation(wallObjects[pos]))

							setElementRotation(doorObjects[pos], 0, 0, doorRotations[doorObjects[pos]] + rz)
							setElementCollisionsEnabled(doorObjects[pos], false)
							setElementModel(wallObjects[pos], editorModels.door2)
						end
					end
				end
			end
		end
	end
end
registerEvent("interiorEdit:updateDynamicData", getRootElement(), updateDynamicData)

function saveDynamicData()
	local data = ""

	if daytimeMode then
		data = "on;"
	else
		data = "off;"
	end

	for k, v in pairs(doorStates) do
		if v then
			if v == "damaged" then
				data = data .. "d" .. k .. "|"
			else
				data = data .. k .. "|"
			end
		end
	end

	data = data .. "-"

	triggerServerEvent("interiorEdit:updateDynamicData", localPlayer, activeInteriorId, data, getElementsByType("player", getRootElement(), true))
end

function onClientPlayerWeaponFire(weapon, ammo, ammoInClip, hitX, hitY, hitZ, hitElement, startX, startY, startZ)
	if hitElement then
		if doorPositions[hitElement] then
			local pos = doorPositions[hitElement]

			if doorStates[pos] ~= "damaged" then
				doorStates[pos] = "damaged"
				saveDynamicData()
			end
		elseif wallPositions[hitElement] and getElementModel(hitElement) == editorModels.door2 then
			local pos = table.concat(wallPositions[hitElement], ",")

			setElementCollisionsEnabled(doorObjects[pos], true)

			local endX = startX + (hitX - startX) * 2
			local endY = startY + (hitY - startY) * 2
			local endZ = startZ + (hitZ - startZ) * 2

			local element = select(5, processLineOfSight(startX, startY, startZ, endX, endY, endZ, false, false, false, true, false, false, false, false, hitElement))
			
			if element == doorObjects[pos] then
				doorStates[pos] = "damaged"
				saveDynamicData()
			else
				setElementCollisionsEnabled(doorObjects[pos], false)
			end
		end
	end
end

function rotateAround(theta, x, y, x2, y2)
	x2 = x2 or 0
	y2 = y2 or 0

	return x + (x2 - x) * math.cos(theta) - (y2 - y) * math.sin(theta),
		   y + (x2 - x) * math.sin(theta) + (y2 - y) * math.cos(theta)
end

function getPositionFromMatrixOffset(matrix, x, y, z)
	return x * matrix[1][1] + y * matrix[2][1] + z * matrix[3][1] + matrix[4][1],
		   x * matrix[1][2] + y * matrix[2][2] + z * matrix[3][2] + matrix[4][2],
		   x * matrix[1][3] + y * matrix[2][3] + z * matrix[3][3] + matrix[4][3]
end

function setElementInteriorAndDimension(element, interior)
	setElementInterior(element, interior)
	setElementDimension(element, activeInteriorId)
end

local destroyElementEx = destroyElement
function destroyElement(element)
	if isElement(element) then
		destroyElementEx(element)
	end
end

function playSoundEx(path)
	if soundState then
		playSound(path)
	end
end

if debugMode then
	local h1, h2, h3 = debug.gethook() 
	debug.sethook()

	local furnitures = {2332, 2964}

	--[[
	for k, v in pairs(availableFurnitures) do
		for i = 1, #v do
			table.insert(furnitures, v[i])
		end
	end
	]]

	local testItem = 1
	local box = ""

	function testElem(element)
		local model = getElementModel(element)
		local diameter = getElementRadius(element) * 2
		local minX = -999
		local minY = -999
		local minZ = -999
		local maxX = 999
		local maxY = 999
		local maxZ = 999

		for x = -diameter, diameter, 0.01 do
			for y = -diameter, diameter, 0.01 do
				local hit, hitX, hitY, hitZ, hitElement = processLineOfSight(x, y, 4, x, y, -4, false, false, false, true)

				if hit and hitElement == element then
					if x < maxX then
						maxX = x
					end

					if minX < x then
						minX = x
					end

					if y < maxY then
						maxY = y
					end

					if minY < y then
						minY = y
					end
				end
			end
		end

		if maxX ~= 999 then
			for z = -diameter, diameter, 0.01 do
				local hit, hitX, hitY, hitZ, hitElement = processLineOfSight(minX + 1, minY + 1, z, maxX - 1, maxY - 1, z, false, false, false, true)

				if hit and hitElement == element then
					if z < maxZ then
						maxZ = z
					end

					if minZ < z then
						minZ = z
					end
				end
			end
		end

		if maxZ ~= 999 then
			box = box .. "[" .. model .. "] = {" .. table.concat({minX, minY, minZ, maxX, maxY, maxZ, (minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2}, ", ") .. "},\n"
		end

		destroyElement(element)

		if testItem < #furnitures then
			testItem = testItem + 1
			outputDebugString("test: " .. furnitures[testItem])

			local obj = createObject(furnitures[testItem], 0, 0, 0)

			setElementInteriorAndDimension(obj, 1)
			setElementStreamable(obj, false)
			setTimer(testElem, 500, 1, obj)
		else
			if fileExists("boundingBox.csv") then
				fileDelete("boundingBox.csv")
			end
			
			local file = fileCreate("boundingBox.csv")

			if file then
				fileWrite(file, box)
				fileClose(file)
			end

			outputDebugString("Test finished.")
		end
	end

	local obj = createObject(furnitures[testItem], 0, 0, 0)

	setElementInteriorAndDimension(obj, 1)
	setElementStreamable(obj, false)
	setTimer(testElem, 500, 1, obj)

	debug.sethook(_, h1, h2, h3)
end